[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BI1001 Biostatistics Practicals",
    "section": "",
    "text": "Practical 1 – Basics of R\nPractical 1 – Exploring data and graphing\nPractical 2 – Experimental design\nPractical 2 – Correlation analysis\nPractical 4 – Group comparisons\nPractical 5 – Analysing count data"
  },
  {
    "objectID": "index.html#practicals",
    "href": "index.html#practicals",
    "title": "BI1001 Biostatistics Practicals",
    "section": "🧪 Practicals",
    "text": "🧪 Practicals\n\nPractical 1 – Basics of R\nPractical 1 – Exploring data and graphing\nPractical 2 – Experimental design\nPractical 2 – Correlation analysis\nPractical 4 – Group comparisons\nPractical 5 – Analysing count data"
  },
  {
    "objectID": "Practical 1 - Basics of R.html",
    "href": "Practical 1 - Basics of R.html",
    "title": "Practical 1 - Basics of R",
    "section": "",
    "text": "Learning Outcomes (LOs)\nHere’s what you should know and be able to do after completing this practical:\n\nLO1: Use R like a calculator (addition, subtraction, division, multiplication)\nLO2: Perform some basic functions (like the square root function)\nLO3: Create simple objects\nLO4: Create sequences and repeats of numbers\nLO5: Apply basic functions on objects\nLO6: Calculate some basic descriptive statistics\nLO7: Install and load packages in R\nLO8: Cite R and R packages\n\n\n\nTutorial\nYou should copy code in this tutorial and paste it into your script in R. Then, click on the line of code and then click “Run” in the top-right of your script pane (or press Ctrl+R or Ctrl+Enter)\n\nBasic calculations: Addition, subtraction, etc.\nR can be used just like a calculator\n\nSum:\n\n3+5\n\n[1] 8\n\n\n\n\nDivide:\n\n100/20\n\n[1] 5\n\n\n\n\nMinus:\n\n10-5\n\n[1] 5\n\n\n\n\nMultiply:\n\n10*2\n\n[1] 20\n\n\nNOTE: The usual rules of precedence apply (multiplication happens before addition):\n\n5+2*10\n\n[1] 25\n\n\nYou can use parentheses to make sure that specific code is run first:\n\n(5+2)*10\n\n[1] 70\n\n\nNOTE: You cannot use curly {} or square [] brackets for this (they have other functions)\n\n\nPower transformations\nR can be used to perform power transformations\nFor example, you can raise 10 to the power of 4 to get 10,000:\n\n10^4\n\n[1] 10000\n\n\nRaising 10 to the power of 4 is the same as doing 10x10x10x10\n\n\nSquare root\nIf you raise something to the power of 0.5, that is the same as taking the square root.\nRemember that a square root is just “the number that, when multiplied by itself, gives the original number.”\nFor example, the square root of 100 is 10, because when 10 is multiplied by itself you get 100:\n\nsqrt(100)\n\n[1] 10\n\n\nNOTE: Raising a number to the power of 0.5 does the same thing:\n\n100^0.5\n\n[1] 10\n\n\nThe sqrt() above is the first example of a function in R (more on this later)\n\n\nFractions\nR also understands fractions:\n\n1/3\n\n[1] 0.3333333\n\n\nStrictly speaking the above is 0.333 recurring\n\n1/5\n\n[1] 0.2\n\n\n\n1/8\n\n[1] 0.125\n\n\n\n\n\nThings that are already built into R\nR has lots of useful things built into it:\nThe 26 upper-case letters of the Roman alphabet letters:\n\nLETTERS\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\nThe 26 lower-case letters of the Roman alphabet:\n\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\nThe three-letter abbreviations for the English month names:\n\nmonth.abb\n\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\n\nThe English names for the months of the year:\n\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nThe ratio of the circumference of a circle to its diameter:\n\npi\n\n[1] 3.141593\n\n\n\n\nTrigonometry\nR can do trigonometry!\nDon’t worry about the mathematics - I just want you to know what’s possible:\n\nsin(1)\n\n[1] 0.841471\n\ncos(1)\n\n[1] 0.5403023\n\ntan(1)\n\n[1] 1.557408\n\n\n\nInfinity\nR understands infinity (and minus infinity):\n\n1/0\n\n[1] Inf\n\n-1/0\n\n[1] -Inf\n\n\n\n\nUndefined numbers\nR also understands things that aren’t numbers.\nFor example if you divide zero by zero, you get “NaN” (“Not a Number”)\n\n0/0\n\n[1] NaN\n\n\n\n\n\nCreating objects\nCreating objects is probably the most important thing you’ll learn in R\nObjects can be anything you want them to be. Numbers, words, datasets, pictures, and more!\nWe can create “objects” by using the “assignment operator”: &lt;-\nFor example, create a new object called “data” which contains the numbers 1 to 5:\n\ndata &lt;- 1:5\n\nThis “data” object will now appear in your Environment (top-right)\nNow, if we simply type the name of that object and run it, we will see what it contains:\n\ndata\n\n[1] 1 2 3 4 5\n\n\nWe can also create objects that contain words.\nFor example, here’s a motivational phrase:\n\nphrase &lt;- \"Well done, you're doing great!\"\n\nAgain, we can type the name of that object and we’ll see that phrase:\n\nphrase\n\n[1] \"Well done, you're doing great!\"\n\n\nThis might seem a little abstract now, but soon you will be creating objects that consist of data that we plot and perform statistical analysis on!\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow it’s your turn to have a go:\nWrite the code to create an object called “new” and put the numbers 1 to 10 in that object.\n\n\n\n\n\nUsing “functions”\nEqually as important as creating objects is being able to use functions\nFunctions are specific blocks of code that perform specific tasks\n\nSum function:\nFor example, let’s look at the sum() function, which simply sums things together:\n\nsum(3, 5)\n\n[1] 8\n\nsum(4, 4, 10)\n\n[1] 18\n\n\n\n\nConcatenate function:\nA very useful function in R is “concatenate”. This is written as c()\nThis function groups things together (that’s what “concatenate” means!)\nHere’s an example:\nLet’s say we wanted to group some numbers together\nNOTE: You can’t run just a list of numbers. You will get an error message:\n\n2, 4, 6, 8, 10\n\nYou also cannot do this even if the numbers are inside parentheses.\nYou will still get an error:\n\n(2, 4, 6, 8, 10)\n\nWe can only do this if we use the concatenate function: c()\nAnd you have to put the numbers inside parentheses, with each number separated by a comma\nGroup together some even numbers:\n\nc(2, 4, 6, 8, 10)\n\n[1]  2  4  6  8 10\n\n\nWe could store these numbers inside an object:\n\neven &lt;- c(2, 4, 6, 8, 10)\n\nWe can now perform mathematical calculations on these numbers:\n\n10*even\n\n[1]  20  40  60  80 100\n\neven^2\n\n[1]   4  16  36  64 100\n\n\nYou can also group words together and store these in an object:\n\nanimals &lt;- c(\"dog\", \"cat\", \"gull\", \"cow\")\n\nBut of course you can’t perform mathematical calculations on words!\nThe following will give you an error:\n\nanimals*10\n\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow it’s your turn.\nWrite your own code to create an object called “names” and store inside that object your own name and the name of the person sitting next to you.\n\n\n\n\n\n\nDoing things with “objects”\nWhat you’ve just had a go at above is creating an object and then doing something with it. This is actually one of the most common things you’ll be doing in R. So, let’s have some more practice.\nCreate an object (called “obj”), which contains 4 numbers:\n\nobj &lt;- c(1, 5, 10, 100)\n\nNow we can do things like add 5 to all of the numbers in that object:\n\nobj+5\n\n[1]   6  10  15 105\n\n\nOr multiply them all by 10:\n\nobj*10\n\n[1]   10   50  100 1000\n\n\nLet’s create a different object, called “x1”.\nx1 will contain the letter A and some words:\n\nx1 &lt;- c(\"A\", \"mean\", \"mode\", \"variance\", \"statistics\")\n\n\n\nR is case-sensitive\nNOTE: R is “case-sensitive”\nThis means that you must be careful to use lower-case or upper-case correctly\nThis ALWAYS catches beginners out!\nFor example, now that you have created the “x1” object, if you type “X1”, it won’t work!\n\nX1\n\nThis tells you object ‘X1’ not found, because you didn’t create X1, you created x1\nIn exactly the same way, if you tried to run “Obj” that would give you an error too:\n\nObj\n\nBecause as far as R knows, nothing called “Obj” exists (only the lower case “obj”)\n\nStr() function\nWe can now perform the structure function str() on any object (“str” stands for “Structure”).\nThe structure function tells us about an object - in this case the x1 object is a “Character vector” (a list of characters i.e., words or symbols):\n\nstr(x1)\n\n chr [1:5] \"A\" \"mean\" \"mode\" \"variance\" \"statistics\"\n\n\nIt also tells us that this object contains 1 to 5 elements [1:5] and that specifically these elements are “A”, “mean”, “mode”, “variance”, and “statistics”.\n\n\n\nDifferent types of objects\nIn the “Introduction to R Coding” lecture you saw different types of objects we can create in R. Specifically, you saw Character, Factor, Integer, and Numeric objects.\nLet’s create an example of each.\n\nCharacter\nA character object just contains words or symbols:\n\nchr &lt;- c(\"students\", \"administrators\", \"teachers\")\nstr(chr)\n\n chr [1:3] \"students\" \"administrators\" \"teachers\"\n\n\n\n\nInteger\nAn integer is an object that contains only whole numbers:\n\nint &lt;- c(1, 2, 3, 4, 5)\nstr(int)\n\n num [1:5] 1 2 3 4 5\n\n\n\n\nNumeric\nA numeric object is a number that also contains decimal places:\n\nnum &lt;- c(1.1, 1.2, 1.3, 1.4, 1.5)\nstr(num)\n\n num [1:5] 1.1 1.2 1.3 1.4 1.5\n\n\n\n\nFactor\nNext we will create a factor. A factor is an object that can contain both words and numbers. However, the important thing to remember is that a factor object has categories.\nSo, we could create category1, category2, etc.\nImportantly, if the same thing appears multiple times in a factor, R will understand that this represents multiple observations from the same category.\nTo create a factor you need to use the function as.factor():\n\nfct &lt;- as.factor(c(\"category1\", \"category1\", \"category2\", \"category3\"))\nstr(fct)\n\n Factor w/ 3 levels \"category1\",\"category2\",..: 1 1 2 3\n\n\nNotice how the factor looks different to the character. R detects that there are 3 levels (categories).\nA factor recognises that there are specific categorical groups, whereas a character variable just treats each element as completely unique.\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow you have a go.\nCreate a factor called “exp” which contains a “control” and “treatment” group.\n\n\n\n\n\n\nGenerating number sequences\nR can be used to generate sequences of numbers using the seq() function:\nLet’s sequence numbers from 0 to 10 in intervals of 1:\n\nseq1 &lt;- seq(0, 10, 1)\nseq1\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\nOr sequence from 0 to 1000 in intervals of 50:\n\nseq2 &lt;- seq(0, 1000, 50)\nseq2\n\n [1]    0   50  100  150  200  250  300  350  400  450  500  550  600  650  700\n[16]  750  800  850  900  950 1000\n\n\n\n\nGenerate repeated sequences:\nWe can use the function rep() to generate repeated things:\nThis will repeat 4, 10 times:\n\nrep(4, 10)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nOr the letter A, 5 times:\n\nrep(\"A\", 5)\n\n[1] \"A\" \"A\" \"A\" \"A\" \"A\"\n\n\nRemember the character object we created earlier, called “chr”?\nWe could apply the rep() function to that object.\nFor example, ask R to repeat “chr” twice:\n\nrep(chr, 2)\n\n[1] \"students\"       \"administrators\" \"teachers\"       \"students\"      \n[5] \"administrators\" \"teachers\"      \n\n\n\n\nAsking R for help\nYou can ask R for help with a function by putting a question mark in front of the function:\n\n?rep\n\nThis will bring up a help page that tells you about that function.\nThese pages can be a bit tricky to understand at first, but with practice you will learn how to interpret them.\nIf you scroll down to the very bottom of that help page you can see some “Examples” that demonstrate how the function can be used.\nFor the rep() function, a good way to use it is by stating each = X where X is the number of times you want each number to be repeated.\nFor example, let’s repeat the numbers 1, 2, 3 each 3 times:\n\nrep(c(1, 2, 3), each = 3)\n\n[1] 1 1 1 2 2 2 3 3 3\n\n\n\n\nArguments\nWhat you have just seen above (the use of “each” inside the rep() function) is an example of an “Argument”.\nArguments are the specific instructions we give to # different functions to specify exactly how those functions are to be used.\nThe rep() function can use the times argument instead of each. This will change how many times the thing that you specify is repeated.\nFor example, repeat “1, 2, 3” three times:\n\nrep(c(1, 2, 3), times = 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\n\nYou should be able to see how this is different to the previous example.\nCompare them:\n\nrep(c(1, 2, 3), each = 3)\n\n[1] 1 1 1 2 2 2 3 3 3\n\nrep(c(1, 2, 3), times = 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\n\n\n\nCalculating basic statistics\nR can very easily and quickly calculate basic descriptive statistics.\nLet’s create an object called “numbers” and then calculate some basic statistics:\n\nnumbers &lt;- c(1, 5, 10, 100, 200)\n\nUse the sum() function to add all the numbers together:\n\nsum(numbers)\n\n[1] 316\n\n\nThe min() function tells you the minimum number:\n\nmin(numbers)\n\n[1] 1\n\n\nmax() tells you the maximum number:\n\nmax(numbers)\n\n[1] 200\n\n\nrange() shows you both the minimum and maximum:\n\nrange(numbers)\n\n[1]   1 200\n\n\nmedian() shows you the middle number:\n\nmedian(numbers)\n\n[1] 10\n\n\nmean() calculates the mean value (add them all up and divide by how many there are):\n\nmean(numbers)\n\n[1] 63.2\n\n\nThe sd() function calculates the Standard Deviation (a measure of variability):\n\nsd(numbers)\n\n[1] 86.82569\n\n\nThe var() calculates the variance (this is another measure of variability)\n\nvar(numbers)\n\n[1] 7538.7\n\n\nIn fact, the variance is the standard deviation squared:\n\nsd(numbers)^2\n\n[1] 7538.7\n\n\n\n\nUsing one object to create another:\nWe can store results of our calculations in new objects.\nSo here, we apply the mean() function to the numbers object, and store the result of that in a new object called “avg”:\n\navg &lt;- mean(numbers)\navg\n\n[1] 63.2\n\n\n\n\nCalculating Standard Error of the Mean (SEM)\nCalculating a mean is something you will probably need to do quite a lot.\nIt’s important therefore to know that whenever we calculate a mean, what we are actually doing is estimating a value. Because this is an estimation, it will come with some error.\nWhen we calculate a mean we therefore must always also calculate how much error we have in our estimate. This is called the Standard Error of the Mean (SEM).\nIf we want to calculate the SEM, we can do it like this…\nFirst we can create a function:\n\nSEM &lt;- function(x) sd(x)/sqrt(length(x))\n\nNOTE: I’m not expecting you to be able to create your own functions - this is quite advanced!\nBut for anyone who is interested, all this line of code above does is tell R that we want to create a new function which we can apply to “x”.\n“x” in this case represents anything we choose to apply that function to.\nSpecifically, we want the function to calculate the standard deviation of x. Then, divide that by the square root of how many observations there are in x.\nNOTE: The length() function calculates how many elements there are in an object.\nLet’s quickly see length() in action in a simple example:\nIn our “numbers” object there are 5 numbers (1, 5, 10, 100 and 200).\nSo length will give us the answer 5.\n\nlength(numbers)\n\n[1] 5\n\n\nSo, in summary, what the Standard Error of the Mean (SEM) function does is calculates the standard deviation (the variability) of the data and then divides that by the square root of how many data points there are.\nIf you want to see that written mathematically, it’s:\n\\[\n\\text{SEM} = \\frac{s}{\\sqrt{n}}\n\\] We can apply the SEM function now to our numbers object.\nNOTE: We apply the SEM function to the raw data, not the estimated mean itself.\n\nSEM(numbers)\n\n[1] 38.82963\n\n\nThe SEM essentially represents how precise our estimated mean is.\nSo the mean of “numbers” could be reported as:\n63.2 ± 38.82963\nThe 38.82963 here represents how much error there is around our estimated mean value of 63.2.\n\n\nMissing observations (NA)\nWhenever you collect data in science, there’s a chance that you may not be able to collect all of the observations you had planned to.\nIn those cases, you are likely to have missing observations.\nFor example, imagine I wanted to measure the heights (cm) of 5 patients, but one of the patients didn’t turn up to the clinic. I would have one missing observation. That could look something like this:\n\nheights &lt;- c(165, 168, 174, NA, 170)\n\nWhen you have a missing value in your observations, R will not be able to calculate statistics from those numbers.\nFor example mean() will not give you a number, but rather NA:\n\nmean(heights)\n\n[1] NA\n\n\nThis is because you can’t calculate the mean of “165, 168, 174, NA, and 170”.\nIn order to calculate the mean of the numbers only, you must remove any missing observations; you must remove the NA.\nThe easiest way to do this is by using the “na.rm” argument.\nIn this example we set na.rm to “TRUE” to tell R to remove the NAs.\nNow it can calculate the number for us:\n\nmean(heights, na.rm = TRUE)\n\n[1] 169.25\n\n\nNOTE: This is also required for many of the other basic descriptive statistics calculations you did earlier. Here are a couple more examples:\n\nsd(heights)\n\n[1] NA\n\nsd(heights, na.rm = TRUE)\n\n[1] 3.774917\n\nmin(heights)\n\n[1] NA\n\nmin(heights, na.rm = TRUE)\n\n[1] 165\n\n\nSo, in summary, if you have missing observations in your data, make sure to use na.rm = TRUE.\n\n\nRounding numbers\nR can be very helpful in rounding numbers for us.\nThis is easily done using the round() function.\nThis is very important, not least because in some of your assignments you will be asked to round numbers to an “appropriate number of decimal places”.\nHere’s an example of how we can round a number in R to a specific number of decimal places.\nWe simply use the round() function:\n\nround(35.684, 1)\n\n[1] 35.7\n\n\nThe “1” in the above tells R to round the number to 1 decimal place.\nIf you needed to, for example, measure something to a precision of 0.01μg/mL, this would represent 2 decimal places:\n\nround(35.684, 2)\n\n[1] 35.68\n\n\n\n\nGenerating random numbers\nWe generated specific sequences earlier, and repeated numbers. But R can also generate (simulate) random data. You will come to learn that this is key for statistics.\nWe can use the rnorm() function to generate data from a normal distribution.\nThe rnorm() function has three arguments: n, mean, and sd\n\nn = the number of observations you want to simulate\nmean = this is the mean value of the normal distribution you want to simulate from\nsd = this is the sd of the distribution\n\nLet’s simulate 30 numbers from a distribution with a mean of 5, and a SD of 1:\n\nrNum &lt;- rnorm(n = 30, mean = 5, sd = 1)\nrNum\n\n [1] 6.167669 5.057183 5.941927 5.546070 3.767478 2.886207 3.724482 4.974249\n [9] 3.903738 5.550198 6.614280 4.802678 4.443351 6.430941 6.343992 4.115385\n[17] 3.761996 4.029446 5.686474 5.694078 5.012846 4.932377 4.364064 3.610650\n[25] 5.857590 5.487381 5.785088 3.239031 4.847095 5.534359\n\n\nRemember, this is a random number generator, so these 30 numbers may not have an exact mean of 5 and a standard deviation of 1. Let’s have a look:\n\nmean(rNum)\n\n[1] 4.937077\n\nsd(rNum)\n\n[1] 1.015572\n\n\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow you have a go.\nCreate an object called “rNum2” which simulates 100 numbers from a distribution with a mean of 5 and an sd of 1. Then, calculate the mean and sd of that object.\n\n\n\n\n\nInstalling new R packages\nWhen you first install R on your device, or use R online for the first time, it will contain lots of different functions that you can use. However, not everything is automatically installed.\nIf you want to install new things into R, you can! This is called installing packages.\nR packages are banks of functions.\nTo install a new package you need to use the install.packages() function, and make sure to write the name of the package in quotation marks.\nFor example, install the “maps” package:\n\ninstall.packages(\"maps\", repos = \"https://cloud.r-project.org/\")\n\nInstalling package into 'C:/Users/sbiwk/AppData/Local/R/win-library/4.5'\n(as 'lib' is unspecified)\n\n\npackage 'maps' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n    C:\\Users\\sbiwk\\AppData\\Local\\Temp\\Rtmp8ClIPq\\downloaded_packages\n\n\nThen you must always run the library() function to open that package:\n\nlibrary(\"maps\")\n\nWarning: package 'maps' was built under R version 4.5.1\n\n\nNow we can use the map() function (which comes from the “maps” package):\n\nmap(\"world\")\n\n\n\n\n\n\n\n\nNOTE: We will explore more data visualisations like this one in the next script.\n\n\nCiting R\nWhenever we use R in a report or assignment we should cite it.\nTo get the R citation we just run citation()\n\ncitation()\n\nIf we want to cite a specific package we can do it like this:\n\ncitation(\"maps\")\n\n\n\n\nTasks\nWrite your own code to complete the following 6 tasks. NOTE: You will not be assessed on these tasks. They are just designed to encourage you to practice.\nNOTE: You aren’t expected to remember how to do all of these yet!\nHINT: Look back at earlier sections of your script to find the bits of code that you need, and adapt them (that’s the best way to work in R)\n\n\n\n\n\n\nNoteTask 1\n\n\n\n\n\nCreate an object called “seq1” which consists of a sequence of numbers from 5 to 100, in intervals of 1\n\n\n\n\n\n\n\n\n\nNoteTask 2\n\n\n\n\n\nCalculate the middle value of seq1\n\n\n\n\n\n\n\n\n\nNoteTask 3\n\n\n\n\n\nWhat is the total value of this sequence of numbers?\n\n\n\n\n\n\n\n\n\nNoteTask 4\n\n\n\n\n\nInstall and load the “car” package\n\n\n\n\n\n\n\n\n\nNoteTask 5\n\n\n\n\n\nCopy and paste here the citation for the “car” package:\n\n\n\n\n\n\n\n\n\nNoteTask 6\n\n\n\n\n\nFinally, create a random set of ten-thousand numbers from a normal distribution with a mean of 5 and a standard deviation of 2"
  },
  {
    "objectID": "index.html#welcome-to-bi1001-biostatistics-practicals",
    "href": "index.html#welcome-to-bi1001-biostatistics-practicals",
    "title": "BI1001 Biostatistics Practicals",
    "section": "",
    "text": "This site contains all the practicals for the BI1001 Biostatistics module.\nClick on a practical below to get started:"
  },
  {
    "objectID": "Practical 1 - Exploring data and graphing.html",
    "href": "Practical 1 - Exploring data and graphing.html",
    "title": "Practical 1 - Exploring data and graphing",
    "section": "",
    "text": "Learning Outcomes (LOs)\nHere’s what you should know and be able to do after completing this practical:\n\nLO1: Create a basic plot using plot()\nLO2: Create a dataframe\nLO3: Explore a dataframe\nLO4: Create boxplots, q-q plots, histograms, and scatterplots\nLO5: Subset data using subset() and indexing []\nLO6: Calculate some basic descriptive statistics\nLO7: Import data into R\nLO8: Remove objects from the R Environment\n\n\n\nTutorial\n\nSimple plot of data\nR can be used to plot data\nLet’s create some objects and plot them against each other:\n\nX &lt;- seq(1, 100, 1)\nY &lt;- rnorm(100, 10, 5)\nplot(Y ~ X)\n\n\n\n\n\n\n\n\nNOTE: Here we use a new function; the plot() function\nWe have also used a new symbol ~\nThis symbol is called “tilde”\nWhenever you see it, think of the phrase “as a function of”\nHence here we are plotting Y as a function of X\n\n\nBasic data exploration\nNext, we are going to create some objects, and then combine them in a dataframe\nNOTE: In R, a dataset is called a “dataframe”\n\nID &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\")\nheight &lt;- rnorm(12, 160, 12)\nweight &lt;- rnorm(12, 70, 10)\ngender &lt;- rep(c(\"male\",\"female\",\"non-binary\"), each = 4)\n\nIf you don’t recognise any of the code or functions above, look back at the Practical 1 - Basics of R script.\nWe can now combine these objects into a dataframe, which we will call dframe1:\n\ndframe1 &lt;- data.frame(ID, height, weight, gender)\n\nThis dataset contains the heights and weights of 12 different people. These people are coded with anonymous identification letters. The heights and weights are randomly simulated.\nWe can now use some simple functions to explore the dataset:\n\nNames\nWe can use the names() function to see what the column names are:\n\nnames(dframe1)\n\n[1] \"ID\"     \"height\" \"weight\" \"gender\"\n\n\n\n\nHead\nUse head() to view the first few rows:\n\nhead(dframe1)\n\n  ID   height   weight gender\n1  A 158.9723 74.42155   male\n2  B 157.8801 85.12134   male\n3  C 159.4477 64.16854   male\n4  D 182.2614 61.02877   male\n5  E 133.2562 60.37246 female\n6  F 145.7029 61.04565 female\n\n\n\n\nTail\nUse tail() to view the last few rows:\n\ntail(dframe1)\n\n   ID   height    weight     gender\n7   G 150.3080  83.96804     female\n8   H 169.0553  59.57936     female\n9   I 170.7844 106.12259 non-binary\n10  J 158.6810  73.82158 non-binary\n11  K 158.8572  88.52473 non-binary\n12  L 169.9087  53.24868 non-binary\n\n\n\n\nView\nIf you want to look at the whole dataset, like you would see it in a spreadsheet, you can use View()\nNOTE: This will open in a new tab next to your script. You need to click on the “x” to close it.\n\nView(dframe1)\n\n\n\nStructure\nExamine the structure of the dataset using str(). Remember that we looked at this function in the previous script, as applied to a single variable. Here we are applying it to a dataset:\n\nstr(dframe1)\n\n'data.frame':   12 obs. of  4 variables:\n $ ID    : chr  \"A\" \"B\" \"C\" \"D\" ...\n $ height: num  159 158 159 182 133 ...\n $ weight: num  74.4 85.1 64.2 61 60.4 ...\n $ gender: chr  \"male\" \"male\" \"male\" \"male\" ...\n\n\nWe can see that these data contain two character variables, and two numeric variables. If we wanted to change a character variable to a factor, we could do it like this:\n\ndframe1$gender &lt;- as.factor(dframe1$gender)\n\nYou will have noticed that we used the dollar symbol $ to specifically choose the gender column from the dframe1 dataset.\n\n\nSummary\nThen we can use the summary() function, which shows us some basic descriptive statistics or other information from the variables in the dataset.\n\nsummary(dframe1)\n\n      ID                height          weight              gender \n Length:12          Min.   :133.3   Min.   : 53.25   female    :4  \n Class :character   1st Qu.:156.0   1st Qu.: 60.86   male      :4  \n Mode  :character   Median :158.9   Median : 69.00   non-binary:4  \n                    Mean   :159.6   Mean   : 72.62                 \n                    3rd Qu.:169.3   3rd Qu.: 84.26                 \n                    Max.   :182.3   Max.   :106.12                 \n\n\n\n\n\nPlotting data\nLet’s now have a go at plotting some of the data from dframe1.\n\nPlot\nLet’s start by plotting the height using plot()\nNOTE: If we want to plot a single variable from the dataset, we use the dollar symbol $ to specify. plot() will just shows us the values of the variable on the y-axis, with the “index” (the observation number) on the x-axis:\n\nplot(dframe1$height)\n\n\n\n\n\n\n\n\n\n\nBoxplot\nWe can plot a boxplot() as follows:\n\nboxplot(dframe1$height)\n\n\n\n\n\n\n\n\nNote that there is some code you will see later which allows us to add y-axis and x-axis labels. Boxplots are good at looking at the distribution of data. It also shows us if there are any possible outliers.\n\n\nHistogram\nWe can use histograms with hist() to examine the distribution of the data:\n\nhist(dframe1$height)\n\n\n\n\n\n\n\n\n\n\nQ-Q plots (Quantile-Quantile plot)\nFinally, we can use a Q-Q plot. This will also inform us about the distribution of the data.\nNOTE: We plot a Q-Q plot using the qqnorm() function. However, we also need to use qqline() to plot a diagonal line on the plot:\n\nqqnorm(dframe1$height)\nqqline(dframe1$height)\n\n\n\n\n\n\n\n\nIf our data were normally distributed, we would expect our observations (the points) to sit on the diagonal line.\nNOTE: It’s sometimes easier to execute two functions on the same line of code.\nYou can do this by separating your functions by a semi-colon, like this:\n\nqqnorm(dframe1$height); qqline(dframe1$height)\n\n\n\n\n\n\n\n\nTo make sure you know what a Q-Q plot will look like for normally distributed data, let’s simulate a larger sample and plot that:\n\nsample &lt;- rnorm(1000, 10, 1) \nqqnorm(sample); qqline(sample)\n\n\n\n\n\n\n\n\nYou’ll see in the above that most of the observations sit on the diagonal line. There may be a small number of observations that don’t sit perfectly on the line, but that’s fine. What you don’t want to see are considerable or consistent deviations away from the diagonal.\n\n\n\nSubsetting a dataframe with indexing\nSometimes we may want to only look at some observations from a dataset. To do this we would need to perform “subsetting”. We can subset in a few ways.\nFirst, we’re going to look at “indexing”. We use square brackets [] for this.\nAll we do is we type the name of the dataframe object, and then put square brackets afterwards. Then, we put two numbers in those square brackets.\nThe first number represents the row number(s) and the second number represents the column number(s).\nFor example, look at the observations in the first row:\n\ndframe1[1,]\n\n  ID   height   weight gender\n1  A 158.9723 74.42155   male\n\n\nBecause we have not specified any columns, we get them all.\nNext, let’s look at all of the rows for the first column:\n\ndframe1[,1]\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\"\n\n\nIf we want to look at more than one column or row at a time, we can easily do that:\n\ndframe1[1:2,]\n\n  ID   height   weight gender\n1  A 158.9723 74.42155   male\n2  B 157.8801 85.12134   male\n\ndframe1[,1:2]\n\n   ID   height\n1   A 158.9723\n2   B 157.8801\n3   C 159.4477\n4   D 182.2614\n5   E 133.2562\n6   F 145.7029\n7   G 150.3080\n8   H 169.0553\n9   I 170.7844\n10  J 158.6810\n11  K 158.8572\n12  L 169.9087\n\n\nWe could also state directly the column names instead:\n\ndframe1[,c(\"ID\", \"height\")]\n\n   ID   height\n1   A 158.9723\n2   B 157.8801\n3   C 159.4477\n4   D 182.2614\n5   E 133.2562\n6   F 145.7029\n7   G 150.3080\n8   H 169.0553\n9   I 170.7844\n10  J 158.6810\n11  K 158.8572\n12  L 169.9087\n\n\nAnd here is an example of doing a combination of both. Specifically, let’s look at the height and weight column only for the first 3 individuals:\n\ndframe1[1:3, 2:3]\n\n    height   weight\n1 158.9723 74.42155\n2 157.8801 85.12134\n3 159.4477 64.16854\n\ndframe1[1:3, c(\"height\",\"weight\")]\n\n    height   weight\n1 158.9723 74.42155\n2 157.8801 85.12134\n3 159.4477 64.16854\n\n\nNOTE: If we wanted to, we could store this inside a new object. Here I name that object “sub” which is short for subset:\n\nsub &lt;- dframe1[1:3, c(\"height\",\"weight\")]\n\nWe can use subsetting to overwrite values in a dataset.\nFor example, imagine we found that the 3rd weight value in the data was erroneous.\nWe would in that case want to replace that value with NA (a missing observation).\nTo do that we could simply write:\n\ndframe1[3, \"weight\"] &lt;- NA\n\nNow if we look at the weight of the first few individuals, we can see that the third one has changed to NA:\n\ndframe1[1:5, \"weight\"]\n\n[1] 74.42155 85.12134       NA 61.02877 60.37246\n\n\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow you have a go at some indexing.\nCreate an object called “sub2” and store inside that object the weight and gender data for the first 5 individuals\n\n\n\n\n\nSelecting observations from a specific column:\nWe can also select specific observations from a single column using indexing.\nNOTE: When we do this, because a single variable doesn’t have both rows and columns, we don’t need two numbers inside the square brackets. Instead, we can use something called a logical statement.\nFor example, let’s look at the heights of individuals that only identify as male. To do this we take the height column from the dataset, and then index it specifically for when gender is equal to male:\n\ndframe1$height[dframe1$gender==\"male\"]\n\n[1] 158.9723 157.8801 159.4477 182.2614\n\n\nThe use of two equal symbols is important. You’ll notice if you try to run this same line of code with only 1 equal symbol, it gives you an error:\n\ndframe1$height[dframe1$gender=\"male\"]\n\nThis is because strictly speaking the two equals symbols is the comparison operator. It checks equality. Whereas the single equal symbol actually performs the same thing as the assignment operator &lt;-\nThe way I remember it is to think of the first equal sign as meaning “is” and the second equal sign as meaning “equal to”. Hence two equals signs means: “is equal to”.\nThus, this line of code is literally asking R to tell you the height data when gender “is equal to” male.\nIf we wanted to, we could calculate the mean height of the male individuals:\n\nmean(dframe1$height[dframe1$gender==\"male\"])\n\n[1] 164.6404\n\n\nIf we wanted to now calculate the mean weight of the male individuals, we would in theory use the same code, but just change height to weight:\n\nmean(dframe1$weight[dframe1$gender==\"male\"])\n\n[1] NA\n\n\nHmm… That’s odd. Why is it showing us NA?\nThat’s because, as you’ll remember from the Basics of R script, when there are\nNAs in the data, R cannot calculate a mean unless you put na.rm = TRUE\nLet’s try it with that added in:\n\nmean(dframe1$weight[dframe1$gender==\"male\"], na.rm = TRUE)\n\n[1] 73.52389\n\n\nNow it works.\nHINT: A slightly adapted version of the line of code above might come in handy for the BI1004 SBA!\n\n\nSubsetting using the subset() functions\nWe can also perform subsetting using the subset() function.\nLet’s subset only the individuals with ID of “A”, “B”, and “C”:\n\nsubset(dframe1, ID %in% c(\"A\",\"B\",\"C\"))\n\n  ID   height   weight gender\n1  A 158.9723 74.42155   male\n2  B 157.8801 85.12134   male\n3  C 159.4477       NA   male\n\n\nAgain we could store this inside an object, if we wanted to:\n\nABC &lt;- subset(dframe1, ID %in% c(\"A\",\"B\",\"C\"))\nABC\n\n  ID   height   weight gender\n1  A 158.9723 74.42155   male\n2  B 157.8801 85.12134   male\n3  C 159.4477       NA   male\n\n\nWe can again perform logical statements in the subset function.\nFor example, subset individuals taller than 160cm:\n\nover160cm &lt;- subset(dframe1, height &gt; 160)\nover160cm\n\n   ID   height    weight     gender\n4   D 182.2614  61.02877       male\n8   H 169.0553  59.57936     female\n9   I 170.7844 106.12259 non-binary\n12  L 169.9087  53.24868 non-binary\n\n\nOr individuals who weigh less than 65 kg\n\nunder65kg &lt;- subset(dframe1, weight &lt; 65)\nunder65kg\n\n   ID   height   weight     gender\n4   D 182.2614 61.02877       male\n5   E 133.2562 60.37246     female\n6   F 145.7029 61.04565     female\n8   H 169.0553 59.57936     female\n12  L 169.9087 53.24868 non-binary\n\n\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow you have a go.\nUse the subset function to create a subset for only the male and females\n\n\n\n\n\nRemoving objects from the “R Environment”\nIf we wanted to remove something that we have created in R, such as an object or dataframe, we can use the function rm()\nFor example, let’s remove the “over160cm” and “under65kg” objects:\n\nrm(over150cm)\n\nWarning in rm(over150cm): object 'over150cm' not found\n\nrm(over65kg)\n\nWarning in rm(over65kg): object 'over65kg' not found\n\n\nIn fact we could type more than one thing inside rm()\nLet’s remove both “ABC” and “sub”:\n\nrm(sub, ABC)\n\nIf you want to know what R has in it’s Environment at any time, you can simply run the ls() function:\n\nls()\n\n [1] \"dframe1\"   \"gender\"    \"height\"    \"ID\"        \"over160cm\" \"sample\"   \n [7] \"under65kg\" \"weight\"    \"X\"         \"Y\"        \n\n\nIn fact, we can use this to remove everything from R’s Environment.\nCAUTION: Be very careful using this code, because it will delete everything you had already created in R!\n\nrm(list=ls())\n\nIf you ran the code above, it will have cleared your Environment. See on the right-hand side, your “Environment” is now empty.\n\n\nImporting data\nLet’s start working with some real data\nWe are going to be looking at some physiological data collected on students\nSpecifically, we’re going to be looking at the “Respiratory Flow” dataset\nThese data are saved in a file called “RespiratoryFlow.csv”\nGo to Learning Central and download “RespiratoryFlow.csv”\nThis dataset measures respiratory flow in a sample of students.\nThe dataset also contains some other variables: height, weight, age and gender.\nOnce you have downloaded the data, you can then use the read.csv() function to import it.\nInside the read.csv() function, we include another function called file.choose()\nIMPORTANT: If you run this code, it will open a new window on your device. You will need to navigate to the dataset that you have downloaded (it will most likely be in your “Downloads” folder) and then select it and open it:\n\nflowData &lt;- read.csv(file.choose(), header = T, na.strings = \"\", stringsAsFactors = T)\n\nNOTE: There is a lot going on in the above line of code:\n\nheader = T: This tells R that the first row in the dataset consists of column headers\nna.strings = \"\": This tells R that any cells in the dataset which are blank need to be set to “NA”\nstringsAsFactors = T: This tells R that any words or letters (i.e. characters) in the dataset should be set as factors i.e. categorical groups.\n\n\n\nExplore the data\nYou should now have “flowData” in your Environment. You can now explore the data:\n\nnames(flowData)\n\n[1] \"student\" \"height\"  \"weight\"  \"age\"     \"gender\" \n\nhead(flowData)\n\n  student height weight age gender\n1       1    163   63.4  20      F\n2       2    173   66.9  18      F\n3       3    168   65.0  18      F\n4       4    169   82.0  18      F\n5       5    162   59.0  18      F\n6       6    172   68.0  19      F\n\ntail(flowData)\n\n    student height weight age gender\n206     206    174   64.2  18      M\n207     207    176   61.9  19   &lt;NA&gt;\n208     208    165     NA  NA   &lt;NA&gt;\n209     209    176   75.0  19   &lt;NA&gt;\n210     210    173   56.0  21   &lt;NA&gt;\n211     211    167   60.0  21   &lt;NA&gt;\n\nstr(flowData)\n\n'data.frame':   211 obs. of  5 variables:\n $ student: int  1 2 3 4 5 6 7 8 9 10 ...\n $ height : num  163 173 168 169 162 172 159 161 171 172 ...\n $ weight : num  63.4 66.9 65 82 59 68 52 51.6 64.8 68 ...\n $ age    : int  20 18 18 18 18 19 18 20 19 18 ...\n $ gender : Factor w/ 2 levels \"F\",\"M\": 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(flowData)\n\n    student          height          weight            age        gender   \n Min.   :  1.0   Min.   :147.0   Min.   : 37.20   Min.   :17.0   F   :126  \n 1st Qu.: 53.5   1st Qu.:167.0   1st Qu.: 58.92   1st Qu.:18.0   M   : 80  \n Median :106.0   Median :173.0   Median : 65.20   Median :18.0   NA's:  5  \n Mean   :106.0   Mean   :173.1   Mean   : 68.16   Mean   :18.8             \n 3rd Qu.:158.5   3rd Qu.:179.0   3rd Qu.: 75.00   3rd Qu.:19.0             \n Max.   :211.0   Max.   :210.0   Max.   :178.00   Max.   :28.0             \n                                 NA's   :1        NA's   :1                \n\n\n\n\nPlot some of the data\nLet’s start by plotting height against weight. We can include lots of arguments in the plot() function to tell R some specific details of what it should plot.\nFor example:\n\nUse xlab to change the x-axis label\nUse ylab to change the y-axis label\npch = plot character. Here we are using number 20 - see ?pch\ncol = \"red\" changes the colour of the points to red\nChanging the las changes the rotation of the axis labels. If you set las = 1, it makes the axis labels all horizontal\n\n\nplot(flowData$height ~ flowData$weight, \n     xlab = \"Height (cm)\",\n     ylab = \"Weight (kg)\",\n     pch = 20,\n     col = \"red\",\n     las = 1)\n\n\n\n\n\n\n\n\nNext, let’s look at a boxplot which shows us how height varies between genders:\n\nboxplot(flowData$height ~ flowData$gender, \n        ylab = \"Height (cm)\", \n        xlab = \"Gender\", \n        names = c(\"Female\", \"Male\"), \n        pch = 20, \n        las = 1)\n\n\n\n\n\n\n\n\nNow, these data don’t have any information about ethnicity, so let’s make some up!\nFirst, create an object called “ethnicities” which contains 4 different ethnicities:\n\nethnicities &lt;- as.factor(c(\"White\", \"Black\", \"Asian\", \"Other\"))\n\nThen, we can use the sample() function to randomly select an ethnicity for each observation in our flowData. We can store this inside a new column we create called ethnicity:\n\nflowData$ethnicity &lt;- sample(ethnicities, 211, replace = T)\n\nThe sample code is saying the following:\nRandomly sample from the ethnicities object. Specifically, randomly select 211 observations. The replace = T sets replacement to TRUE. This means once an ethnicity has been selected, it is then put back and so can by chance be selected again.\nNow that we have these data, we could produce a boxplot that shows data across two categorical groups (both gender and ethnicity):\n\nboxplot(flowData$height ~ flowData$gender * flowData$ethnicity, \n        ylab = \"Height (cm)\", \n        xlab = \"Gender\", \n        pch = 20, \n        las = 3)\n\n\n\n\n\n\n\n\nOh, there’s an issue with this figure.\nThe Gender x-axis label overlaps with the names of the groups.\nOne solution is to plot the figure, but do not display an x-axis just yet:\n\nboxplot(flowData$height ~ flowData$gender * flowData$ethnicity, \n        ylab = \"Height (cm)\", \n        xlab = \"\", \n        pch = 20, \n        las = 3)\n\n\n\n\n\n\n\n\nThen you could write in the figure legend that “F” and “M” represent Female and Male, respectively.\nAlternatively, we could use some code to change the way the figure is plotted so that there is more space to show the x-axis label. Here’s how we do this:\n\npar(mar = c(7, 4, 4, 2))\n\npar() is the function to change graphical parameters. The mar argument allows us to set the size of the margins (bottom, top, left, right).\nBy default the margins are c(5, 4, 4, 2) + 0.1.\nWe have set these to c(7, 4, 4, 2)\nNow we can re-plot the boxplot and you’ll see there’s more space at the bottom.\nAnd we can manually add an x-axis label using the mtext() function:\n\nboxplot(flowData$height ~ flowData$gender * flowData$ethnicity, \n        ylab = \"Height (cm)\", \n        xlab = \"\", \n        pch = 20, \n        las = 3)\nmtext(\"Gender.Ethnicity\", side = 1, line = 4.5)\n\n\n\n\n\n\n\n\n\nside = 1 tells R to plot the text on the bottom axis\nline = 4.5 tells R how far down the bottom axis to plot (higher number = further down)\n\n\n\nExamine the data distributions\nRemember from the lecture that the distribution of data is important to examine.\nWe can apply histograms and Q-Q plots to numeric data:\n\nhist(flowData$height)\n\n\n\n\n\n\n\nqqnorm(flowData$height);qqline((flowData$height))\n\n\n\n\n\n\n\n\nheight looks quite normal.\nWhat about weight?\n\nhist(flowData$weight)\n\n\n\n\n\n\n\nqqnorm(flowData$weight);qqline((flowData$weight))\n\n\n\n\n\n\n\n\nThis definitely looks odd - there is a clear curved pattern in the data.\nWe can also plot the distribution of categorical data. We can do this just using plot().\nWhen plot() is applied to a categorical variable, it will default to a barplot and show us how many observations of each category exists:\n\nplot(flowData$gender)\n\n\n\n\n\n\n\nplot(flowData$ethnicity)\n\n\n\n\n\n\n\n\nIn fact, we can see the same numbers by using the table() function:\n\ntable(flowData$gender)\n\n\n  F   M \n126  80 \n\ntable(flowData$ethnicity)\n\n\nAsian Black Other White \n   48    53    44    66 \n\n\nIf we wanted to plot a barplot specifically, we can’t just apply barplot to a categorical variable. The following will give you an error:\n\nbarplot(flowData$gender)\n\nThis is because barplot needs numbers to plot. These numbers would represent the heights of the bars. In fact, we can get this from the table() function, so we could use that:\n\nbarplot(table(flowData$gender))\n\n\n\n\n\n\n\n\n\n\nData transformations\nLet’s look again at the weight data:\n\nhist(flowData$weight)\n\n\n\n\n\n\n\n\nThis does not look normally distributed. Indeed, we saw that in the Q-Q plot:\n\nqqnorm(flowData$weight); qqline(flowData$weight)\n\n\n\n\n\n\n\n\nLet’s apply some mathematical transformations to the weight values to see if we can make them normally distributed.\nNOTE: You can nest a transformation function e.g. log() within a plotting function e.g., hist()\nLet’s try a natural logarithm transformation first:\n\nhist(log(flowData$weight))\n\n\n\n\n\n\n\nqqnorm(log(flowData$weight)); qqline(log(flowData$weight))\n\n\n\n\n\n\n\n\nlog looks better.\nWhat about a square root transformation?\n\nhist(sqrt(flowData$weight))\n\n\n\n\n\n\n\nqqnorm(sqrt(flowData$weight)); qqline(sqrt(flowData$weight))\n\n\n\n\n\n\n\n\nThis looks a bit worse.\nWhat about an exponential transformation?\n\nhist(exp(flowData$weight))\n\n\n\n\n\n\n\nqqnorm(exp(flowData$weight)); qqline(exp(flowData$weight))\n\n\n\n\n\n\n\n\nThis definitely hasn’t worked!\nThe best one was log() so let’s stick with that one.\nWe can store a transformed version of a variable inside the original dataset by creating a new column:\n\nflowData$logWeight &lt;- log(flowData$weight)\n\n\n\nAdding colour to a scatterplot\nSo far we have seen how to plot a scatter plot with two variables.\nThe following code shows you how to add a third variable to a plot using colour.\nStart by choosing the two colours you want to represent male and female, respectively:\n\ncolours &lt;- c(M = \"black\", \n             F = \"lightgrey\")\n\nThen, when you plot the data, you can use some clever indexing in the col argument.\nNOTE: You must make sure the variable is a “Character” for this to work.\n\nplot(height ~ weight, data = flowData, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = colours[as.character(flowData$gender)], \n     las = 1)\n\n\n\n\n\n\n\n\nRemember that plots like these should have a legend, otherwise it’s not obvious what the colours represent.\nLet’s plot it again but this time including a legend:\n\nplot(height ~ weight, data = flowData, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = colours[as.character(flowData$gender)], \n     las = 1)\nlegend(\"bottomright\", \n       legend = c(\"Male\", \"Female\"), \n       col = c(\"black\", \"lightgrey\"),\n       pch = 20, \n       title = \"Gender\") \n\n\n\n\n\n\n\n\n\nbottomright = Position of the legend\nlegend = c(\"Male\", \"Female\") = Labels in the legend\ncol = = Colours corresponding to the labels\npch = 20 = Symbol used in the legend\ntitle = = Title of the legend\n\nNote that you don’t have to change the colours, you could change the plot characters:\n\nchrs &lt;- c(M = 16, \n          F = 1)\nplot(height ~ weight, \n     data = flowData, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = chrs[as.character(flowData$gender)], \n     col = \"black\", \n     las = 1)\nlegend(\"bottomright\",\n       legend = c(\"Male\", \"Female\"),\n       col = \"black\",\n       pch = c(16, 1),\n       title = \"Gender\")\n\n\n\n\n\n\n\n\n\n\nPlotting data separately\nAlternatively you could plot males and females separately in two plots.\nStart by creating two subsets of the data:\n\nmale &lt;- subset(flowData, gender == \"M\") \nfemale &lt;- subset(flowData, gender == \"F\") \n\nNow use the droplevels() function to remove any categories that are no longer needed:\n\nmale &lt;- droplevels(male)\nfemale &lt;- droplevels(female)\n\nBefore we create the plots, we can change the way R displays subsequent figures.\nWe can do this again using par() but this time using the mfrow argument\nmfrow=c(1,2) means that the NEXT plots you produce will exist in a 1 row, 2 column array:\n\npar(mfrow=c(1,2))\nplot(height ~ weight, \n     data = female, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"black\", \n     las = 1)\nplot(height ~ weight, \n     data = male, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"red\", \n     las = 1)\n\n\n\n\n\n\n\n\nWe could make it so that they appear one above the other rather than side-by-side:\n\npar(mfrow=c(2,1))\nplot(height ~ weight, \n     data = female, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"black\", \n     las = 1)\nplot(height ~ weight, \n     data = male, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"red\", \n     las = 1)\n\n\n\n\n\n\n\n\nIf we are going to compare them like this then it makes more sense to put them all on the same axes.\nHence we can use xlim and ylim to adjust the axes ranges.\nWe can also use xaxp to adjust the positions of the x-axis tick marks to c(start, end, number of ticks).\n\npar(mfrow=c(2,1))\nplot(height ~ weight, \n     data = female, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"black\", \n     las = 1, \n     xlim = c(35, 185), \n     ylim = c(145, 215),\n     xaxp = c(30, 190, 16))\nplot(height ~ weight, \n     data = male,\n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"red\",\n     las = 1, \n     xlim = c(35, 185), \n     ylim = c(145, 215),\n     xaxp = c(30, 190, 16))\n\n\n\n\n\n\n\n\nSo, hopefully you can see that there are lots of ways to explore data!\nWe can change the plot region back to normal with:\n\npar(mfrow=c(1,1))\n\n\n\n\nTasks\nWrite your own code to complete the following 6 tasks. NOTE: You will not be assessed on these tasks. They are just designed to encourage you to practice.\nNOTE: You aren’t expected to remember how to do all of these yet!\nHINT: Look back at earlier sections of your script to find the bits of code that you need, and adapt them (that’s the best way to work in R)\n\n\n\n\n\n\nNoteTask 1\n\n\n\n\n\nSubset the flowData so that you only have data from Asian individuals\n\n\n\n\n\n\n\n\n\nNoteTask 2\n\n\n\n\n\nNow plot the association between height and age of Asian individuals\n\n\n\n\n\n\n\n\n\nNoteTask 3\n\n\n\n\n\nCreate this plot again, but this time provide your own axes labels\n\n\n\n\n\n\n\n\n\nNoteTask 4\n\n\n\n\n\nAgain, create the plot, but this time ALSO change the type of plot symbol\n\n\n\n\n\n\n\n\n\nNoteTask 5\n\n\n\n\n\nNow go back to using the original flowData. Explore transformations of male weight - what looks to be the most “normal”?\n\n\n\n\n\n\n\n\n\nNoteTask 6\n\n\n\n\n\nUsing the original flowData, create a boxplot of weight as a function of gender - which gender looks heavier?\n\n\n\n\n\n\n\n\n\nNoteTask 7\n\n\n\n\n\nType ?boxplot and see if you can work out how to change the “notch” and “boxwex” for your boxplots. Set “notch” to TRUE and boxwex to 0.5"
  },
  {
    "objectID": "Practical 2 - Experimental design.html",
    "href": "Practical 2 - Experimental design.html",
    "title": "Practical 2 - Experimental design",
    "section": "",
    "text": "Learning Outcomes (LOs)\nHere’s what you should know and be able to do after completing this practical:\n\nLO1: Explain different sampling methods\nLO2: Write code to perform different sampling methods\nLO3: Simulate data, including from different distributions\nLO4: Run a basic loop\nLO5: Set a “seed” and explain what it does\nLO6: Explain how increased sample size affects estimates (of things like mean values)\nLO7: Subset data using subset() and indexing\nLO8: Explain the importance of replication\n\n\n\nTUTORIAL\n\nSimulating data and distributions\nIn this script will we be working with entirely simulated data. In other scripts, we will use more real data, but to exemplify experimental design concepts, it’s actually I think more helpful to work with simulated data.\nLet’s imagine a population that consists of 100,000 individuals.\nIn this first example, we are going to simulate the heights of 100,000 people.\nAcross the world, people differ in their heights considerably, but on average if you look across all adults, regardless of sex or gender, it’s reasonable to consider a typical mean height of 170 cm with a standard deviation of 10 cm. For examples, see: https://en.wikipedia.org/wiki/Average_human_height_by_country\nSo, let’s simulate a single variable, which is normally distributed and has a mean of 170 and a SD of 10.\nI’m calling this variable popHeights (population heights):\n\npopHeights &lt;- rnorm(100000, 170, 10)\n\nThis variable has been created using the rnorm() function, which generates random numbers from a normal distribution\nIf you want to see how the rnorm function works (or any function for that matter), type “?” followed by the function name:\n\n?rnorm\n\nWe saw rnorm() in the first script (Practical 1 - Basics of R) but as a reminder:\nThe rnorm() function has three arguments: n, mean, and sd\n\nn = the number of observations you want to simulate\nmean = this is the mean value of the normal distribution you want to simulate from\nsd = this is the sd of the distribution\n\nIf we wanted to, we could plot a quick histogram of the population heights, to take a look:\n\nhist(popHeights)\n\n\n\n\n\n\n\n\nRemember that in most scientific experiments, we wouldn’t collect data from the entire population.\nWe would instead collect a sample. Let’s look at how to do this:\nSuppose we want to measure the heights of a sample of 50 people from our population.\nWe can use the sample() function. We’ll store the sample of heights in a new object called sHeights:\n\nsHeights &lt;- sample(popHeights, 50, replace = FALSE)\n\nImportantly, in the above function I set replace = FALSE. This is to tell R that once an individual has been selected, they cannot be selected again. This is known as sampling without replacement and is typical for real world surveys, because you may not want to sample the same person’s height twice.\nIf I were to set replace = TRUE, this would simulate sampling with replacement: after selecting an individual, that person is returned to the population and could be chosen again.\nScientists sometimes do this in simulations to see how results might vary if we repeated an experiment.\nYou don’t need to worry about this for now — just know that it exists.\nLets look at our sample distribution:\n\nhist(sHeights)\n\n\n\n\n\n\n\n\nWe could, if we wanted to, calculate the mean of our sample:\n\nmean(sHeights)\n\n[1] 171.263\n\n\nWe will explore sample distributions in more detail later. For now, let’s simulate a slightly more realistic scenario - one where we don’t just collect data on 1 variable, but on a few different variables.\nLet’s imagine a population of 100,000 humans who all have different heights, weights, ages, etc.:\n\npopulation &lt;- data.frame(\n  height = rnorm(100000, 170, 10),\n  weight = rnorm(100000, 65, 10),\n  age = rnorm(100000, 40, 15),\n  systolic_bp = rnorm(100000, 120, 15), \n  diastolic_bp = rnorm(100000, 80, 10), \n  cholesterol = rnorm(100000, 5, 1), \n  gender = sample(c(\"Male\", \"Female\", \"Other\"), 100000, replace = TRUE, prob = c(0.49, 0.49, 0.02)),\n  ethnicity = sample(c(\"White\", \"Black\", \"Asian\", \"Other\"), 100000, replace = TRUE, prob = c(0.3, 0.3, 0.3, 0.1)), \n  university = sample(LETTERS[1:10], 100000, replace = TRUE, prob = rep(0.1, 10))\n)\n\nThis simulation should take less than 1 second. R can handle very large datasets very quickly!\nLet’s make sure we tell R that the gender, ethnicity, and university variables are all categorical (factors):\n\npopulation$gender &lt;- as.factor(population$gender)\n\npopulation$ethnicity &lt;- as.factor(population$ethnicity)\n\npopulation$university &lt;- as.factor(population$university)\n\nFor gender, we’ve simulated a population where 49% of people are male, 49% are female, and 2% identify as another gender (e.g., non-binary, transgender, etc.).\nFor ethnicity, we’ve simulated a scenario where 30% of people are White, 30% are Black, 30% are Asian, and 10% belong to other ethnic groups.\nNOTE: These gender and ethnicity proportions are entirely hypothetical and are not intended to reflect real-world population data.\nWe’ve also simulated these people all attending one of 10 different universities.\nLet’s take a look at the first few rows of the dataset we just created:\n\nhead(population)\n\n    height   weight       age systolic_bp diastolic_bp cholesterol gender\n1 181.8917 65.95659 54.043762   136.72015     76.27696    6.751264   Male\n2 152.3525 69.73649 41.885823   121.98966     91.00437    4.852896   Male\n3 161.9172 51.98096 28.842420    89.06611     86.36814    4.673087   Male\n4 175.1414 72.10186  9.956617   110.30854     77.83300    6.643298   Male\n5 165.9646 61.66644 27.424063   110.96473     73.16775    5.290861   Male\n6 184.8499 64.55127 14.819444   124.52521     80.13347    3.699011   Male\n  ethnicity university\n1     Other          F\n2     Asian          F\n3     White          G\n4     White          I\n5     Black          D\n6     Black          I\n\n\nNow we can start looking at some of the possible sampling strategies we might use to sample from this population.\n\n\nRandom sampling\nPick 30 individuals at random from the entire population.\nFirst we create an object called rowNums. In this we store 30 random numbers from 1:100000:\n\nrowNums &lt;- sample(1:100000, 30, replace = F)\n\nThen, we use that to select which rows to choose when performing indexing on our population:\n\nrandom_sample &lt;- population[rowNums, ]\n\nLet’s look at the first few of these randomly sampled individuals:\n\nhead(random_sample)\n\n        height   weight      age systolic_bp diastolic_bp cholesterol gender\n4653  169.7799 73.37108 62.72067    104.5133     64.65091    4.631331 Female\n11246 184.7911 66.92005 59.24338    119.6797     81.44419    6.266655 Female\n34408 180.0082 57.18565 44.89194    113.0768     85.72993    6.560816   Male\n17171 172.0403 77.29059 44.31937    131.6149     70.51090    4.887556   Male\n95866 164.9999 65.87086 45.13674    100.5497     86.16386    4.251617   Male\n42490 185.3999 58.80658 57.34801    112.5643     77.93042    7.105784  Other\n      ethnicity university\n4653      Black          H\n11246     Other          B\n34408     Asian          E\n17171     Black          J\n95866     White          D\n42490     Asian          J\n\n\nNote that the first column that you see represents the original row numbers within the population\n\n\nSystematic sampling\nLet’s now choose every 100th individual within the population. Let’s start by creating a sequence which takes every 100th individual starting from individual number 1:\n\nseq1 &lt;- seq(1, 100000, 100)\n\nThen, we use this seq1 in our indexing:\n\nsystematic_sample &lt;- population[seq1, ]\n\nLet’s look at the first few rows of these:\n\nhead(systematic_sample)\n\n      height   weight       age systolic_bp diastolic_bp cholesterol gender\n1   181.8917 65.95659 54.043762    136.7201     76.27696    6.751264   Male\n101 153.8822 73.98783 46.436233    113.2102     77.79679    5.047658   Male\n201 152.9155 69.85994  3.292137    132.2375     77.24115    5.789151   Male\n301 157.7660 59.62766 30.774110    113.9843     81.75128    4.588415   Male\n401 174.3276 75.95124 42.307131    113.4292     74.93412    5.390191 Female\n501 165.3558 64.54569 -6.853938    108.5050     72.25534    6.938712 Female\n    ethnicity university\n1       Other          F\n101     Asian          C\n201     Black          J\n301     Asian          C\n401     Asian          I\n501     Other          I\n\n\n\n\nStratified random sampling\nIn stratified random sampling we want to take a sample that proportionally represents the population.\nLet’s look at taking a stratified random sample according to gender.\nBefore we take a sample, we need to work out how many individuals we have of each gender. The table() function is good for this:\n\ntable(population$gender)\n\n\nFemale   Male  Other \n 49051  48944   2005 \n\n\nSo this is how many individuals we have of each gender. But what about as a proportion?\nFor this we can apply the prop.table() function to this table:\n\nprop.table(table(population$gender))\n\n\n Female    Male   Other \n0.49051 0.48944 0.02005 \n\n\nSo we have 48.634% female, 49.306% male, and 2.06% other.\nTo keep things simple, let’s round these numbers to whole percentages: 49%, 49% and 2%.\nWe can now use those values to perform our stratified random sampling.\nImagine we wanted a sample of 100 individuals in total. To keep our sample proportionally representative of the population, that would mean we have 49 male, 49 female, and 2 other.\nHere’s one way to do this. First, create some subsets:\n\nmale &lt;- subset(population, gender == \"Male\")\n\nfemale &lt;- subset(population, gender == \"Female\")\n\nother &lt;- subset(population, gender == \"Other\")\n\nNow, we can randomly sample 49, 49, and 2 individual from these respectively:\n\nsMale &lt;- male[sample(1:nrow(male), 49, replace = FALSE), ]\n\nsFemale &lt;- female[sample(1:nrow(female), 49, replace = FALSE), ]\n\nsOther &lt;- other[sample(1:nrow(other), 2, replace = FALSE), ]\n\nExplanation of the above:\n\nFor each gender, we first create a subset of the population.\nThen we use sample() to randomly select the desired number of rows.\nThe 1:nrow(data) part creates a sequence of row numbers that is specific to each dataset so that the sample() function knows which rows to pick from.\n\nWe now have our three subsets. We can combine them using rbind(), which stands for “row bind”.\nrbind() stacks the datasets on top of each other (adds rows), so all the selected individuals are together in one dataset. This works because all three subsets have the same columns and structure.\n\nstratified_sample &lt;- rbind(sMale, sFemale, sOther)\n\nLet’s have a look at this sample either using head() or View():\n\nhead(stratified_sample)\n\n        height   weight      age systolic_bp diastolic_bp cholesterol gender\n41026 163.0809 70.69900 23.99529    121.0283     87.63013    4.546431   Male\n55159 169.7011 44.96024 81.78328    120.0054     77.30928    5.193442   Male\n97107 167.0441 69.72781 31.83209    132.2845     78.10886    5.986965   Male\n95298 169.7894 58.40553 39.36326    123.5954     63.41858    5.950757   Male\n65343 181.0432 68.40817 37.29478    117.4471     79.47869    4.785539   Male\n32980 171.3221 70.93626 26.34709    143.2521     91.34546    3.977288   Male\n      ethnicity university\n41026     Black          H\n55159     White          H\n97107     Other          G\n95298     White          G\n65343     Asian          H\n32980     Black          E\n\n\n\nView(stratified_sample)\n\n\n\nQuota sampling:\nWe can use a very similar approach to perform quota sampling.\nLet’s assume we want data on 5 individuals from each ethnicity.\nFirst, create ethnicity subsets:\n\nAsian &lt;- subset(population, ethnicity == \"Asian\") \nBlack &lt;- subset(population, ethnicity == \"Black\") \nWhite &lt;- subset(population, ethnicity == \"White\") \nOther &lt;- subset(population, ethnicity == \"Other\")\n\nNow select 5 individuals from each subset:\n\nsAsian &lt;- Asian[sample(1:nrow(Asian), 5, replace = FALSE), ] \nsBlack &lt;- Black[sample(1:nrow(Black), 5, replace = FALSE), ] \nsWhite &lt;- White[sample(1:nrow(White), 5, replace = FALSE), ] \nsOther &lt;- Other[sample(1:nrow(Other), 5, replace = FALSE), ]\n\nAnd again rbind() them:\n\nquota_sample &lt;- rbind(sAsian, sBlack, sWhite, sOther)\n\nHave a look, this time just print the entire dataset as it’s only small (20 individuals):\n\nquota_sample\n\n        height   weight      age systolic_bp diastolic_bp cholesterol gender\n66546 173.6025 65.00084 47.53982    109.6991     93.29653    5.238933 Female\n59742 188.7630 53.85722 47.09415    117.3835     73.97170    3.052515   Male\n89278 191.3660 55.22209 16.05946    124.1786     86.84495    4.718466   Male\n38398 169.1332 62.30335 42.91705    126.4840     83.46747    3.161352 Female\n49287 171.4612 68.06520 45.68254    126.2581     63.05222    3.301955 Female\n34276 195.7192 61.38782 48.57233    121.3732    102.17456    5.249173   Male\n46415 164.5650 66.82846 32.71044    137.0233     88.01298    4.953049 Female\n56297 179.5274 71.38645 42.22164    107.8484     90.41166    5.612718 Female\n3843  193.7212 61.34739 46.56138    107.6604     73.73065    3.822007 Female\n37406 157.2184 49.27461 22.60050    121.9938     61.83209    4.713379   Male\n48112 169.0804 62.32836 75.49070    141.8244     96.73715    5.175702   Male\n98442 172.1584 71.47122 36.99733    145.7300     63.61692    4.495889   Male\n87550 177.0591 55.39918 35.61092    116.5942     76.22142    4.509009   Male\n78117 168.9749 74.80501 31.51017    116.2274     85.85864    3.765290   Male\n51190 169.1691 80.52377 40.78356    120.7377     75.10947    5.701031 Female\n43518 163.3178 67.07632 51.71008    116.4906     67.72671    6.632093 Female\n68953 173.7001 73.49131 25.22929    129.7150     84.22430    4.068652 Female\n75349 175.6710 64.12274 29.81824    118.2672     95.02906    5.384948   Male\n20645 169.8536 58.92705 50.05220    120.7502     69.51482    4.399490 Female\n29078 174.2245 77.72705 17.44857    115.0675     77.37110    4.892672   Male\n      ethnicity university\n66546     Asian          E\n59742     Asian          C\n89278     Asian          B\n38398     Asian          D\n49287     Asian          B\n34276     Black          H\n46415     Black          B\n56297     Black          B\n3843      Black          F\n37406     Black          B\n48112     White          A\n98442     White          B\n87550     White          G\n78117     White          H\n51190     White          G\n43518     Other          I\n68953     Other          A\n75349     Other          H\n20645     Other          I\n29078     Other          G\n\n\n\n\nCluster sampling:\nFinally, let’s take a look at cluster sampling.\nThis is where we might select only a few specific clusters (characteristics), but include all individuals who have those characteristics. For example, let’s imagine we only wanted to look at people who went to three different universities (university A, B, and C):\n\nA &lt;- subset(population, university == \"A\") \nB &lt;- subset(population, university == \"B\") \nC &lt;- subset(population, university == \"C\")\n\nIn cluster sampling, we collect data on all individuals from those clusters. So we don’t need to perform any further sampling, we just rbind() the entire three clusters together:\n\nABC &lt;- rbind(A, B, C)\n\nNow we can have a look at it:\n\nhead(ABC)\n\n     height   weight      age systolic_bp diastolic_bp cholesterol gender\n25 160.9578 76.54681 29.75255    128.2268     79.00476    5.783385   Male\n26 155.6095 53.22573 47.03772    105.5600     79.58648    5.425473 Female\n27 180.7766 69.03992 66.54862    117.5942     72.96604    4.005896 Female\n36 163.4919 79.29393 22.46824    113.0934     96.06150    4.308785   Male\n44 162.7147 69.23167 27.00450    102.5662     80.19901    5.043619 Female\n54 174.8940 72.48711 41.74273     95.3446     96.78921    3.311160 Female\n   ethnicity university\n25     White          A\n26     White          A\n27     White          A\n36     Asian          A\n44     White          A\n54     Other          A\n\ntail(ABC)\n\n        height   weight       age systolic_bp diastolic_bp cholesterol gender\n99927 175.4463 75.44739 42.956506   122.65891     80.68062    5.469707 Female\n99929 170.6889 77.88772 45.373440    98.72096     62.88210    5.031693   Male\n99934 157.8411 58.80335 50.913249   142.86610     85.94856    7.020991 Female\n99969 180.2466 63.48501 34.314829   111.83394     65.75705    4.969786 Female\n99976 177.2251 87.76495 38.609772   121.16693     65.15839    4.654630 Female\n99985 174.5995 66.53489 -1.957121   120.00469     84.89809    5.008957   Male\n      ethnicity university\n99927     White          C\n99929     Black          C\n99934     White          C\n99969     Asian          C\n99976     White          C\n99985     Asian          C\n\ntable(ABC$university)\n\n\n    A     B     C     D     E     F     G     H     I     J \n10064 10205 10135     0     0     0     0     0     0     0 \n\n\nNotice how even though there are no longer any observations in the D-J universities, those categories still exist?\nWe can remove empty categories by using the droplevels() function:\n\nABC &lt;- droplevels(ABC)\n\nNow look again:\n\ntable(ABC$university)\n\n\n    A     B     C \n10064 10205 10135 \n\n\n\n\nSimulating data from different distributions\nSo far, whenever we have simulated numerical data, we have used the rnorm() function\nThis will specifically simulate data from a normal distribution.\nLet’s have another quick look at this: let’s simulate 100 normally distributed height observations\n\nheights &lt;- rnorm(n = 100, mean = 170, sd = 10)\n\nWe can look at this distribution using hist()\n\nhist(heights)\n\n\n\n\n\n\n\n\nR can simulate data from many different distributions. Let’s look at a few examples.\n\nPoisson Distribution\nThe Poisson distribution models count data (whole numbers like 0, 1, 2 etc.).\nIt has a single parameter, lambda, which determines both the mean and the variance.\nAn obvious biological example of count data are the number of eggs a bird lays.\nHere we simulate 100 random numbers from a Poisson distribution with lambda = 2:\n\npois &lt;- rpois(n = 100, lambda = 2)\n\nAgain, we can visualise the simulated data with a histogram:\n\nhist(pois, main = \"\", xlab = \"Number of eggs laid\", las = 1)\n\n\n\n\n\n\n\n\n\n\nBinomial Distribution\nThe binomial distribution models data that exists in one of two categories, e.g., success/failure.\nBiological example: We have 100 people suffering from pain and we want to test if a drug can reduce it.\nrbinom() parameters:\n\nn = number of individuals we are simulating (100 here)\nsize = number of “trials” per individual (1 if they get the drug once)\nprob = probability of success on each trial (probability the drug works)\n\n\nExample 1: Drug has 50% chance to reduce pain\n\nbinom &lt;- rbinom(n = 100, size = 1, prob = 0.5)\n\nhist(binom, main = \"\", xlab = \"0 = Same pain, 1 = Reduced pain\", las = 1)\n\n\n\n\n\n\n\n\n\n\nExample 2: Drug has 75% chance to reduce pain\n\nbinom2 &lt;- rbinom(n = 100, size = 1, prob = 0.75)\n\nhist(binom2, main = \"\", xlab = \"0 = Same pain, 1 = Reduced pain\", las = 1)\n\n\n\n\n\n\n\n\n\n\nExample 3: Each person gets 2 doses of the drug (size = 2)\nThe number now represents how many times the drug successfully reduced pain out of two attempts.\nAssuming that on both attempts the chance of reducing pain was 75%:\n\nbinom3 &lt;- rbinom(n = 100, size = 2, prob = 0.75)\n\nhist(binom3, main = \"\", xlab = \"Number of times pain was reduced (0, 1, 2)\", las = 1)\n\n\n\n\n\n\n\n\n\n\n\nBimodal distribution\nYou may remember from the exploring data and graphing lecture, I mentioned that spiders are often sexually dimorphic - females are typically larger than males.\nFor this you will need to install another package (if that doesn’t work, just skip over this bit):\n\ninstall.packages(\"FamilyRank\")\n\nlibrary(FamilyRank)\n\nThis distribution needs a total sample size, a mean and SD for each of the two peaks (modes) in the distribution, and a probability value which dictates the probability of being in mode 1.\n\nbinorm &lt;- rbinorm(n = 200,   # 200 spiders in total \n                  mean1 = 2, # mean for mode 1 (think of male spider diameter in cm) \n                  mean2 = 4, # mean for mode 2 (think of female spider diameter in cm) \n                  sd1 = 0.3, # SD for male spider diameter \n                  sd2 = 0.5, # SD for female spider diameter \n                  p1 = 0.5)  # Probability of being a male spider (50%)\n\nhist(binorm, main = \"\", las = 1, xlab = \"Spider diameter (cm)\")\n\nThere are many more possible distributions that data can follow, but we will stop here for now!\nJust remember (i) that data can follow different distributions - it won’t always be “normal” and (ii) that for many “Parametric” statistical tests, the tests assume your data are normal - so you must check! We will cover this in detail in the next script.\n\n\n\nExamining distributions\nLet’s have a look at some averages, and variation, of the distributions created above:\n\nNormal\n\nhist(heights) \nabline(v = mean(heights), col = \"blue\", lwd = 2) \nabline(v = median(heights), col = \"red\", lwd = 2) \n\n\n\n\n\n\n\nmean(heights) \n\n[1] 170.0839\n\nmedian(heights) \n\n[1] 170.6889\n\nsd(heights)\n\n[1] 10.73436\n\n\n\n\nPoisson\n\nhist(pois) \nabline(v = mean(pois), col = \"blue\", lwd = 2) \nabline(v = median(pois), col = \"red\", lwd = 2) \n\n\n\n\n\n\n\nmean(pois) # This should be close to 2 \n\n[1] 1.9\n\nvar(pois)  # This should be close to 2\n\n[1] 1.606061\n\n\n\n\nBinom\n\nhist(binom) \nabline(v = mean(binom), col = \"blue\", lwd = 2) \nabline(v = median(binom), col = \"red\", lwd = 2) \n\n\n\n\n\n\n\nmean(binom)  # This should be close to 50 % \n\n[1] 0.45\n\ntable(binom) # This should be close to a 50/50 split!\n\nbinom\n 0  1 \n55 45 \n\n\n\n\nBinorm\n\nhist(binorm) \nabline(v = mean(binorm), col = \"blue\", lwd = 2) \nabline(v = median(binorm), col = \"red\", lwd = 2) \nmean(binorm) # The mean of a bimodal distribution is not representative of a \"typical\" or \"average\" spider! \nsd(binorm)\n\nHopefully this exemplifies that best representation of the “average” value in a distribution isn’t always the mean!\n\n\n\nThe importance of sample size\nLook at what happens when we create a normal distribution with 10, 100, or 1000 observations:\n\nhist(rnorm(10,5,1)) \n\n\n\n\n\n\n\nhist(rnorm(100,5,1)) \n\n\n\n\n\n\n\nhist(rnorm(1000,5,1))\n\n\n\n\n\n\n\n\nWith increasing sample size, the distribution starts to look more normal\nWe know that in these simulated distributions the mean = 5 and sd = 1.\nIn theory, with increasing sample size, the estimated mean and SD should get more accurate.\nThis is because with more data (a larger sample size) we can estimate things more accurately.\n\nmean(rnorm(10,5,1)) \n\n[1] 4.825311\n\nmean(rnorm(100,5,1)) \n\n[1] 5.027543\n\nmean(rnorm(1000,5,1))\n\n[1] 4.99873\n\nsd(rnorm(10,5,1)) \n\n[1] 0.8750469\n\nsd(rnorm(100,5,1)) \n\n[1] 1.05303\n\nsd(rnorm(1000,5,1))\n\n[1] 0.9799877\n\n\nLet’s do something a little more complex…\nWe are going to use a “loop” - this is a way of performing repeated instructions over a series of iterations (i).\nBefore we do this, let’s set up our plotting window so that we have a 2 x 2 array of plots.\nWe must do this first (before plotting):\n\npar(mfrow=c(2,2)) # This tells R to plot all subsequent plots in a 2 x 2 array\n\nNow, let’s run a “for loop” to plot 4 histograms, each time with a different sample:\nWe can interpret this code as follows: For every iteration (i) in iterations 1 to 4, create a histogram of 10 observations drawn from a random normal distribution with a mean = 5 and sd = 1\nNOTE: You can run this over and over again, each time it will produce 4 different graphs:\n\nfor(i in 1:4) { \n  hist(rnorm(10, 5, 1)) \n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy does this matter?\nThis demonstrates the impact of replication. Imagine we were to take only a sample of data that consisted of 10 observations. Depending on which 10 observations we happen to select, our sample could look very different!\nOften we only perform an experiment once i.e., we only collect the first sample of 10 observations\nIn fact, we may want to repeat entire experiments multiple times (known as replication) in order to ensure that our results are robust.\nHere’s another example of this:\nSuppose we were measuring the height of young trees i.e., saplings (cm)\nWe won’t know in a real experiment what the true population looks like, but usefully in R we can simulate this.\nLet’s assume that the population consists of 1000 saplings, and on average they are 50 cm tall, with SD of 5 cm:\n\nsaplings &lt;- rnorm(1000, mean = 50, sd = 5)\n\nLet’s imagine now I do an experiment - I sample the heights of just 5 saplings:\n\nsaplings1 &lt;- sample(saplings, 5, replace = F)\n\nIf I now estimate the mean of that sample, what is it?\n\nmean(saplings1)\n\n[1] 52.47439\n\n\nNow let’s imagine I repeat that experiment. I go back into the field on a different day and measure 5 saplings again:\n\nsaplings2 &lt;- sample(saplings, 5, replace = F)\n\nIf I now estimate the mean of that second sample, what is it?\n\nmean(saplings2)\n\n[1] 51.12288\n\n\nThe chances are the means of saplings1 and saplings2 could be quite different to each other and also quite different to the true (simulated) mean of the population\nLet’s see what these samples both look like:\nPlot to visualize:\n\npar(mfrow=c(1,2))\n\nhist(saplings1, main=\"Sample 1 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightblue\", las = 1)\n\nhist(saplings2, main=\"Sample 2 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightgreen\", las = 1)\n\n\n\n\n\n\n\n\nDepending on what you happened to randomly sample on each occasion, these could look quite different!\nIn other words, when you repeat exactly the same experiment, you might end up with quite different results.\nIf you were to repeat this experiment many times, then you could calculate an average sapling height across ALL of your experiments. This would be a much more reliable/robust average than if you’d only done the experiment once.\nNow let’s have a look at if I were to do the experiment only twice, but this time collect a much larger sample of data on both occasions:\n\nsaplings1b &lt;- sample(saplings, 100, replace = F)\n\nsaplings2b &lt;- sample(saplings, 100, replace = F)\n\nIf we plot them again, we should see that these two distributions now look much more similar:\n\npar(mfrow=c(1,2))\n\nhist(saplings1b, main=\"Sample 1 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightblue\", las = 1)\n\nhist(saplings2b, main=\"Sample 2 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightgreen\", las = 1)\n\n\n\n\n\n\n\n\nAnd if we were to calculate their means, not only should these both be more similar to each other, they should also both be more similar to what we know to be the true (simulated) mean in the population:\n\nmean(saplings1b)\n\n[1] 49.99518\n\nmean(saplings2b)\n\n[1] 50.0277\n\n\n\n\nSetting a seed\nThis may seem like an odd concept, but sometimes we want to generate a random set of numbers that is always the same set of random numbers!\nTo do this, we set a “seed”. Think of a seed as a specific instance of R.\nThe seed can be any number and must be set prior to running a random number generator:\n\nset.seed(1); rnorm(5, 5, 1)\n\n[1] 4.373546 5.183643 4.164371 6.595281 5.329508\n\n\nNotice what I have done on the above line is use the semi-colon “;” - This allows me to run two functions on the same line of code, one after the other.\nIf you run that line of code above again, you will always get the same 5 random numbers!\nCompare that to running the below line of code a few times, without setting a seed. You should get a random set of numbers every time:\n\nrnorm(5, 5, 1)\n\n[1] 4.179532 5.487429 5.738325 5.575781 4.694612\n\n\nWhy is setting a seed useful?\nSetting a seed is important for playing with simulations because it ensures results are reproducible every single time. This goes not just for you, but for anyone else running the code.\nSo, in theory, every single person running the following line of code should get the same set of 5 “random” numbers:\n\nset.seed(1); rnorm(5, 5, 1)\n\n[1] 4.373546 5.183643 4.164371 6.595281 5.329508\n\n\n\n\nSubsetting data\nWe have already seen some examples of subsetting data from a previous script, but it’s so useful it’s worth seeing a few more examples:\nLet’s create a new, simulated dataset.\nThis time we’re going to create data on Alzheimer’s patients\nWe are going to do this using a seed so that everyone sees exactly the same simulated data:\n\nset.seed(1); Alzheimers &lt;- data.frame(neurons = c(rnorm(100, 20, 5), rnorm(100, 20, 5)), \n                                      group = rep(c(\"Asymptomatic\",\"Symptomatic\"), each = 100), \n                                      sex = c(rep(\"M\", 50), rep(\"M\", 50), rep(\"F\", 50), rep(\"F\", 50)),\n                                      age = round(rnorm(200, 70, 5), 0))\n\nNote that the “neurons” variable represents the neuron cell density in patients\nHave a quick look:\n\nhead(Alzheimers)\n\n   neurons        group sex age\n1 16.86773 Asymptomatic   M  72\n2 20.91822 Asymptomatic   M  78\n3 15.82186 Asymptomatic   M  78\n4 27.97640 Asymptomatic   M  68\n5 21.64754 Asymptomatic   M  59\n6 15.89766 Asymptomatic   M  82\n\n\nThere are many different ways to subset data:\nSelecting for a particular group e.g. Males (all these 4 lines of code achieve the same thing!):\n\nmales &lt;- subset(Alzheimers, sex == \"M\")\n\nmales &lt;- subset(Alzheimers, sex %in% \"M\")\n\nmales &lt;- Alzheimers[Alzheimers$sex == \"M\", ]\n\nmales &lt;- Alzheimers[Alzheimers$sex %in% \"M\", ]\n\nSelecting against a particular group:\n\nAsymptomatic &lt;- subset(Alzheimers, group != \"Symptomatic\")\n\nSelecting individuals over or under a certain age:\n\nover70 &lt;- subset(Alzheimers, age &gt; 70)\n\nunder70 &lt;- subset(Alzheimers, age &lt; 70)\n\nSelecting individuals “greater than or equal to” a certain age:\n\natLeast60 &lt;- subset(Alzheimers, age &gt;= 60)\n\nSelecting individuals “less than or equal to” a certain age:\n\nage58orLess &lt;- subset(Alzheimers, age &lt;= 58)\n\nSelecting specific rows from a dataset:\n\nfirst10 &lt;- Alzheimers[1:10,]\n\nlast20 &lt;- Alzheimers[181:200,]\n\nSelecting specific rows AND columns:\n\nsubset &lt;- Alzheimers[50:100, 1:2] # Select rows 50 to 100, but only data from the first 2 columns\n\n\n\n\nTASKS\nWrite your own code to complete the following 6 tasks. NOTE: You will not be assessed on these tasks. They are just designed to encourage you to practice.\nNOTE: You aren’t expected to remember how to do all of these yet!\nHINT: Look back at earlier sections of your script to find the bits of code that you need, and adapt them (that’s the best way to work in R)\n\n\n\n\n\n\nNoteTask 1\n\n\n\n\n\nWrite the code to create a randomly generated dataset consisting of observations that follow a Poisson distribution with a mean value of 10. And write the code to plot this distribution.\n\n\n\n\n\n\n\n\n\nNoteTask 2\n\n\n\n\n\nWrite the code to execute a loop that plots 4 random poisson distributions where n = 10 and lambda = 2\n\n\n\n\n\n\n\n\n\nNoteTask 3\n\n\n\n\n\nWrite the code to subset the Alzheimers data so that you have a sample of 50 random individuals\n\n\n\n\n\n\n\n\n\nNoteTask 4\n\n\n\n\n\nWrite the code to plot a histogram of neuron cell density for only Symptomatic Alzheimer’s patients"
  }
]