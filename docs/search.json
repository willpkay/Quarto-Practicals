[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BI1001 Biostatistics Practicals",
    "section": "",
    "text": "This site contains all the practicals for BI1001 Biostatistics.\nClick on a practical below to get started:"
  },
  {
    "objectID": "index.html#practicals",
    "href": "index.html#practicals",
    "title": "BI1001 Biostatistics Practicals",
    "section": "🧪 Practicals",
    "text": "🧪 Practicals\n\nPractical 1 – Basics of R\nPractical 1 – Exploring data and graphing\nPractical 2 – Experimental design and subsampling data\nPractical 2 – Correlation analysis\nPractical 4 – Group comparisons\nPractical 5 – Analysing count data"
  },
  {
    "objectID": "Practical 1 - Basics of R.html",
    "href": "Practical 1 - Basics of R.html",
    "title": "Practical 1 - Basics of R",
    "section": "",
    "text": "Learning Outcomes (LOs)\nHere’s what you should know and be able to do after completing this practical:\n\nLO1: Use R like a calculator (addition, subtraction, division, multiplication)\nLO2: Perform some basic functions (like the square root function)\nLO3: Create simple objects\nLO4: Create sequences and repeats of numbers\nLO5: Apply basic functions on objects\nLO6: Calculate some basic descriptive statistics\nLO7: Install and load packages in R\nLO8: Cite R and R packages\n\n\n\nTutorial\nYou should copy code in this tutorial and paste it into your script in R. Then, click on the line of code and then click “Run” in the top-right of your script pane (or press Ctrl+R or Ctrl+Enter)\n\nBasic calculations: Addition, subtraction, etc.\nR can be used just like a calculator\n\nSum:\n\n3+5\n\n[1] 8\n\n\n\n\nDivide:\n\n100/20\n\n[1] 5\n\n\n\n\nMinus:\n\n10-5\n\n[1] 5\n\n\n\n\nMultiply:\n\n10*2\n\n[1] 20\n\n\nNOTE: The usual rules of precedence apply (multiplication happens before addition):\n\n5+2*10\n\n[1] 25\n\n\nYou can use parentheses to make sure that specific code is run first:\n\n(5+2)*10\n\n[1] 70\n\n\nNOTE: You cannot use curly {} or square [] brackets for this (they have other functions)\n\n\nPower transformations\nR can be used to perform power transformations\nFor example, you can raise 10 to the power of 4 to get 10,000:\n\n10^4\n\n[1] 10000\n\n\nRaising 10 to the power of 4 is the same as doing 10x10x10x10\n\n\nSquare root\nIf you raise something to the power of 0.5, that is the same as taking the square root.\nRemember that a square root is just “the number that, when multiplied by itself, gives the original number.”\nFor example, the square root of 100 is 10, because when 10 is multiplied by itself you get 100:\n\nsqrt(100)\n\n[1] 10\n\n\nNOTE: Raising a number to the power of 0.5 does the same thing:\n\n100^0.5\n\n[1] 10\n\n\nThe sqrt() above is the first example of a function in R (more on this later)\n\n\nFractions\nR also understands fractions:\n\n1/3\n\n[1] 0.3333333\n\n\nStrictly speaking the above is 0.333 recurring\n\n1/5\n\n[1] 0.2\n\n\n\n1/8\n\n[1] 0.125\n\n\n\n\n\nThings that are already built into R\nR has lots of useful things built into it:\nThe 26 upper-case letters of the Roman alphabet letters:\n\nLETTERS\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\nThe 26 lower-case letters of the Roman alphabet:\n\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\nThe three-letter abbreviations for the English month names:\n\nmonth.abb\n\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\n\nThe English names for the months of the year:\n\nmonth.name\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nThe ratio of the circumference of a circle to its diameter:\n\npi\n\n[1] 3.141593\n\n\n\n\nTrigonometry\nR can do trigonometry!\nDon’t worry about the mathematics - I just want you to know what’s possible:\n\nsin(1)\n\n[1] 0.841471\n\ncos(1)\n\n[1] 0.5403023\n\ntan(1)\n\n[1] 1.557408\n\n\n\nInfinity\nR understands infinity (and minus infinity):\n\n1/0\n\n[1] Inf\n\n-1/0\n\n[1] -Inf\n\n\n\n\nUndefined numbers\nR also understands things that aren’t numbers.\nFor example if you divide zero by zero, you get “NaN” (“Not a Number”)\n\n0/0\n\n[1] NaN\n\n\n\n\n\nCreating objects\nCreating objects is probably the most important thing you’ll learn in R\nObjects can be anything you want them to be. Numbers, words, datasets, pictures, and more!\nWe can create “objects” by using the “assignment operator”: &lt;-\nFor example, create a new object called “data” which contains the numbers 1 to 5:\n\ndata &lt;- 1:5\n\nThis “data” object will now appear in your Environment (top-right)\nNow, if we simply type the name of that object and run it, we will see what it contains:\n\ndata\n\n[1] 1 2 3 4 5\n\n\nWe can also create objects that contain words.\nFor example, here’s a motivational phrase:\n\nphrase &lt;- \"Well done, you're doing great!\"\n\nAgain, we can type the name of that object and we’ll see that phrase:\n\nphrase\n\n[1] \"Well done, you're doing great!\"\n\n\nThis might seem a little abstract now, but soon you will be creating objects that consist of data that we plot and perform statistical analysis on!\n\n\n\n\n\n\nHave a go\n\n\n\n\n\nNow it’s your turn to have a go:\nWrite the code to create an object called “new” and put the numbers 1 to 10 in that object.\n\n\n\n\n\nUsing “functions”\nEqually as important as creating objects is being able to use functions\nFunctions are specific blocks of code that perform specific tasks\n\nSum function:\nFor example, let’s look at the sum() function, which simply sums things together:\n\nsum(3, 5)\n\n[1] 8\n\nsum(4, 4, 10)\n\n[1] 18\n\n\n\n\nConcatenate function:\nA very useful function in R is “concatenate”. This is written as c()\nThis function groups things together (that’s what “concatenate” means!)\nHere’s an example:\nLet’s say we wanted to group some numbers together\nNOTE: You can’t run just a list of numbers. You will get an error message:\n\n2, 4, 6, 8, 10\n\nYou also cannot do this even if the numbers are inside parentheses.\nYou will still get an error:\n\n(2, 4, 6, 8, 10)\n\nWe can only do this if we use the concatenate function: c()\nAnd you have to put the numbers inside parentheses, with each number separated by a comma\nGroup together some even numbers:\n\nc(2, 4, 6, 8, 10)\n\n[1]  2  4  6  8 10\n\n\nWe could store these numbers inside an object:\n\neven &lt;- c(2, 4, 6, 8, 10)\n\nWe can now perform mathematical calculations on these numbers:\n\n10*even\n\n[1]  20  40  60  80 100\n\neven^2\n\n[1]   4  16  36  64 100\n\n\nYou can also group words together and store these in an object:\n\nanimals &lt;- c(\"dog\", \"cat\", \"gull\", \"cow\")\n\nBut of course you can’t perform mathematical calculations on words!\nThe following will give you an error:\n\nanimals*10\n\n\n\n\n\n\n\nHave a go\n\n\n\n\n\nNow it’s your turn.\nWrite your own code to create an object called “names” and store inside that object your own name and the name of the person sitting next to you.\n\n\n\n\n\n\nDoing things with “objects”\nWhat you’ve just had a go at above is creating an object and then doing something with it. This is actually one of the most common things you’ll be doing in R. So, let’s have some more practice.\nCreate an object (called “obj”), which contains 4 numbers:\n\nobj &lt;- c(1, 5, 10, 100)\n\nNow we can do things like add 5 to all of the numbers in that object:\n\nobj+5\n\n[1]   6  10  15 105\n\n\nOr multiply them all by 10:\n\nobj*10\n\n[1]   10   50  100 1000\n\n\nLet’s create a different object, called “x1”.\nx1 will contain the letter A and some words:\n\nx1 &lt;- c(\"A\", \"mean\", \"mode\", \"variance\", \"statistics\")\n\n\n\nR is case-sensitive\nNOTE: R is “case-sensitive”\nThis means that you must be careful to use lower-case or upper-case correctly\nThis ALWAYS catches beginners out!\nFor example, now that you have created the “x1” object, if you type “X1”, it won’t work!\n\nX1\n\nThis tells you object ‘X1’ not found, because you didn’t create X1, you created x1\nIn exactly the same way, if you tried to run “Obj” that would give you an error too:\n\nObj\n\nBecause as far as R knows, nothing called “Obj” exists (only the lower case “obj”)\n\nStr() function\nWe can now perform the structure function str() on any object (“str” stands for “Structure”).\nThe structure function tells us about an object - in this case the x1 object is a “Character vector” (a list of characters i.e., words or symbols):\n\nstr(x1)\n\n chr [1:5] \"A\" \"mean\" \"mode\" \"variance\" \"statistics\"\n\n\nIt also tells us that this object contains 1 to 5 elements [1:5] and that specifically these elements are “A”, “mean”, “mode”, “variance”, and “statistics”.\n\n\n\nDifferent types of objects\nIn the “Introduction to R Coding” lecture you saw different types of objects we can create in R. Specifically, you saw Character, Factor, Integer, and Numeric objects.\nLet’s create an example of each.\n\nCharacter\nA character object just contains words or symbols:\n\nchr &lt;- c(\"students\", \"administrators\", \"teachers\")\nstr(chr)\n\n chr [1:3] \"students\" \"administrators\" \"teachers\"\n\n\n\n\nInteger\nAn integer is an object that contains only whole numbers:\n\nint &lt;- c(1, 2, 3, 4, 5)\nstr(int)\n\n num [1:5] 1 2 3 4 5\n\n\n\n\nNumeric\nA numeric object is a number that also contains decimal places:\n\nnum &lt;- c(1.1, 1.2, 1.3, 1.4, 1.5)\nstr(num)\n\n num [1:5] 1.1 1.2 1.3 1.4 1.5\n\n\n\n\nFactor\nNext we will create a factor. A factor is an object that can contain both words and numbers. However, the important thing to remember is that a factor object has categories.\nSo, we could create category1, category2, etc.\nImportantly, if the same thing appears multiple times in a factor, R will understand that this represents multiple observations from the same category.\nTo create a factor you need to use the function as.factor():\n\nfct &lt;- as.factor(c(\"category1\", \"category1\", \"category2\", \"category3\"))\nstr(fct)\n\n Factor w/ 3 levels \"category1\",\"category2\",..: 1 1 2 3\n\n\nNotice how the factor looks different to the character. R detects that there are 3 levels (categories).\nA factor recognises that there are specific categorical groups, whereas a character variable just treats each element as completely unique.\n\n\n\n\n\n\nHave a go\n\n\n\n\n\nNow you have a go.\nCreate a factor called “exp” which contains a “control” and “treatment” group.\n\n\n\n\n\n\nGenerating number sequences\nR can be used to generate sequences of numbers using the seq() function:\nLet’s sequence numbers from 0 to 10 in intervals of 1:\n\nseq1 &lt;- seq(0, 10, 1)\nseq1\n\n [1]  0  1  2  3  4  5  6  7  8  9 10\n\n\nOr sequence from 0 to 1000 in intervals of 50:\n\nseq2 &lt;- seq(0, 1000, 50)\nseq2\n\n [1]    0   50  100  150  200  250  300  350  400  450  500  550  600  650  700\n[16]  750  800  850  900  950 1000\n\n\n\n\nGenerate repeated sequences:\nWe can use the function rep() to generate repeated things:\nThis will repeat 4, 10 times:\n\nrep(4, 10)\n\n [1] 4 4 4 4 4 4 4 4 4 4\n\n\nOr the letter A, 5 times:\n\nrep(\"A\", 5)\n\n[1] \"A\" \"A\" \"A\" \"A\" \"A\"\n\n\nRemember the character object we created earlier, called “chr”?\nWe could apply the rep() function to that object.\nFor example, ask R to repeat “chr” twice:\n\nrep(chr, 2)\n\n[1] \"students\"       \"administrators\" \"teachers\"       \"students\"      \n[5] \"administrators\" \"teachers\"      \n\n\n\n\nAsking R for help\nYou can ask R for help with a function by putting a question mark in front of the function:\n\n?rep\n\nThis will bring up a help page that tells you about that function.\nThese pages can be a bit tricky to understand at first, but with practice you will learn how to interpret them.\nIf you scroll down to the very bottom of that help page you can see some “Examples” that demonstrate how the function can be used.\nFor the rep() function, a good way to use it is by stating each = X where X is the number of times you want each number to be repeated.\nFor example, let’s repeat the numbers 1, 2, 3 each 3 times:\n\nrep(c(1, 2, 3), each = 3)\n\n[1] 1 1 1 2 2 2 3 3 3\n\n\n\n\nArguments\nWhat you have just seen above (the use of “each” inside the rep() function) is an example of an “Argument”.\nArguments are the specific instructions we give to # different functions to specify exactly how those functions are to be used.\nThe rep() function can use the times argument instead of each. This will change how many times the thing that you specify is repeated.\nFor example, repeat “1, 2, 3” three times:\n\nrep(c(1, 2, 3), times = 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\n\nYou should be able to see how this is different to the previous example.\nCompare them:\n\nrep(c(1, 2, 3), each = 3)\n\n[1] 1 1 1 2 2 2 3 3 3\n\nrep(c(1, 2, 3), times = 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\n\n\n\nCalculating basic statistics\nR can very easily and quickly calculate basic descriptive statistics.\nLet’s create an object called “numbers” and then calculate some basic statistics:\n\nnumbers &lt;- c(1, 5, 10, 100, 200)\n\nUse the sum() function to add all the numbers together:\n\nsum(numbers)\n\n[1] 316\n\n\nThe min() function tells you the minimum number:\n\nmin(numbers)\n\n[1] 1\n\n\nmax() tells you the maximum number:\n\nmax(numbers)\n\n[1] 200\n\n\nrange() shows you both the minimum and maximum:\n\nrange(numbers)\n\n[1]   1 200\n\n\nmedian() shows you the middle number:\n\nmedian(numbers)\n\n[1] 10\n\n\nmean() calculates the mean value (add them all up and divide by how many there are):\n\nmean(numbers)\n\n[1] 63.2\n\n\nThe sd() function calculates the Standard Deviation (a measure of variability):\n\nsd(numbers)\n\n[1] 86.82569\n\n\nThe var() calculates the variance (this is another measure of variability)\n\nvar(numbers)\n\n[1] 7538.7\n\n\nIn fact, the variance is the standard deviation squared:\n\nsd(numbers)^2\n\n[1] 7538.7\n\n\n\n\nUsing one object to create another:\nWe can store results of our calculations in new objects.\nSo here, we apply the mean() function to the numbers object, and store the result of that in a new object called “avg”:\n\navg &lt;- mean(numbers)\navg\n\n[1] 63.2\n\n\n\n\nCalculating Standard Error of the Mean (SEM)\nCalculating a mean is something you will probably need to do quite a lot.\nIt’s important therefore to know that whenever we calculate a mean, what we are actually doing is estimating a value. Because this is an estimation, it will come with some error.\nWhen we calculate a mean we therefore must always also calculate how much error we have in our estimate. This is called the Standard Error of the Mean (SEM).\nIf we want to calculate the SEM, we can do it like this…\nFirst we can create a function:\n\nSEM &lt;- function(x) sd(x)/sqrt(length(x))\n\nNOTE: I’m not expecting you to be able to create your own functions - this is quite advanced!\nBut for anyone who is interested, all this line of code above does is tell R that we want to create a new function which we can apply to “x”.\n“x” in this case represents anything we choose to apply that function to.\nSpecifically, we want the function to calculate the standard deviation of x. Then, divide that by the square root of how many observations there are in x.\nNOTE: The length() function calculates how many elements there are in an object.\nLet’s quickly see length() in action in a simple example:\nIn our “numbers” object there are 5 numbers (1, 5, 10, 100 and 200).\nSo length will give us the answer 5.\n\nlength(numbers)\n\n[1] 5\n\n\nSo, in summary, what the Standard Error of the Mean (SEM) function does is calculates the standard deviation (the variability) of the data and then divides that by the square root of how many data points there are.\nIf you want to see that written mathematically, it’s:\n\\[\n\\text{SEM} = \\frac{s}{\\sqrt{n}}\n\\] We can apply the SEM function now to our numbers object.\nNOTE: We apply the SEM function to the raw data, not the estimated mean itself.\n\nSEM(numbers)\n\n[1] 38.82963\n\n\nThe SEM essentially represents how precise our estimated mean is.\nSo the mean of “numbers” could be reported as:\n63.2 ± 38.82963\nThe 38.82963 here represents how much error there is around our estimated mean value of 63.2.\n\n\nMissing observations (NA)\nWhenever you collect data in science, there’s a chance that you may not be able to collect all of the observations you had planned to.\nIn those cases, you are likely to have missing observations.\nFor example, imagine I wanted to measure the heights (cm) of 5 patients, but one of the patients didn’t turn up to the clinic. I would have one missing observation. That could look something like this:\n\nheights &lt;- c(165, 168, 174, NA, 170)\n\nWhen you have a missing value in your observations, R will not be able to calculate statistics from those numbers.\nFor example mean() will not give you a number, but rather NA:\n\nmean(heights)\n\n[1] NA\n\n\nThis is because you can’t calculate the mean of “165, 168, 174, NA, and 170”.\nIn order to calculate the mean of the numbers only, you must remove any missing observations; you must remove the NA.\nThe easiest way to do this is by using the “na.rm” argument.\nIn this example we set na.rm to “TRUE” to tell R to remove the NAs.\nNow it can calculate the number for us:\n\nmean(heights, na.rm = TRUE)\n\n[1] 169.25\n\n\nNOTE: This is also required for many of the other basic descriptive statistics calculations you did earlier. Here are a couple more examples:\n\nsd(heights)\n\n[1] NA\n\nsd(heights, na.rm = TRUE)\n\n[1] 3.774917\n\nmin(heights)\n\n[1] NA\n\nmin(heights, na.rm = TRUE)\n\n[1] 165\n\n\nSo, in summary, if you have missing observations in your data, make sure to use na.rm = TRUE.\n\n\nRounding numbers\nR can be very helpful in rounding numbers for us.\nThis is easily done using the round() function.\nThis is very important, not least because in some of your assignments you will be asked to round numbers to an “appropriate number of decimal places”.\nHere’s an example of how we can round a number in R to a specific number of decimal places.\nWe simply use the round() function:\n\nround(35.684, 1)\n\n[1] 35.7\n\n\nThe “1” in the above tells R to round the number to 1 decimal place.\nIf you needed to, for example, measure something to a precision of 0.01μg/mL, this would represent 2 decimal places:\n\nround(35.684, 2)\n\n[1] 35.68\n\n\n\n\nGenerating random numbers\nWe generated specific sequences earlier, and repeated numbers. But R can also generate (simulate) random data. You will come to learn that this is key for statistics.\nWe can use the rnorm() function to generate data from a normal distribution.\nThe rnorm() function has three arguments: n, mean, and sd\n\nn = the number of observations you want to simulate\nmean = this is the mean value of the normal distribution you want to simulate from\nsd = this is the sd of the distribution\n\nLet’s simulate 30 numbers from a distribution with a mean of 5, and a SD of 1:\n\nrNum &lt;- rnorm(n = 30, mean = 5, sd = 1)\nrNum\n\n [1] 4.783457 5.516569 5.351782 5.349868 2.271099 5.689304 5.895269 4.226902\n [9] 3.118741 3.343010 6.995136 5.944610 6.599657 6.475672 4.946277 4.700266\n[17] 6.082356 3.976083 3.824021 5.843837 4.246029 6.878735 4.667689 5.161807\n[25] 4.821145 5.847011 3.041809 4.678737 3.166725 3.400196\n\n\nRemember, this is a random number generator, so these 30 numbers may not have an exact mean of 5 and a standard deviation of 1. Let’s have a look:\n\nmean(rNum)\n\n[1] 4.894793\n\nsd(rNum)\n\n[1] 1.241425\n\n\n\n\n\n\n\n\nHave a go\n\n\n\n\n\nNow you have a go.\nCreate an object called “rNum2” which simulates 100 numbers from a distribution with a mean of 5 and an sd of 1. Then, calculate the mean and sd of that object.\n\n\n\n\n\nInstalling new R packages\nWhen you first install R on your device, or use R online for the first time, it will contain lots of different functions that you can use. However, not everything is automatically installed.\nIf you want to install new things into R, you can! This is called installing packages.\nR packages are banks of functions.\nTo install a new package you need to use the install.packages() function, and make sure to write the name of the package in quotation marks.\nFor example, install the “maps” package:\n\ninstall.packages(\"maps\", repos = \"https://cloud.r-project.org/\")\n\nInstalling package into 'C:/Users/sbiwk/AppData/Local/R/win-library/4.5'\n(as 'lib' is unspecified)\n\n\npackage 'maps' successfully unpacked and MD5 sums checked\n\n\nWarning: cannot remove prior installation of package 'maps'\n\n\nWarning in file.copy(savedcopy, lib, recursive = TRUE): problem copying\nC:\\Users\\sbiwk\\AppData\\Local\\R\\win-library\\4.5\\00LOCK\\maps\\libs\\x64\\maps.dll to\nC:\\Users\\sbiwk\\AppData\\Local\\R\\win-library\\4.5\\maps\\libs\\x64\\maps.dll:\nPermission denied\n\n\nWarning: restored 'maps'\n\n\n\nThe downloaded binary packages are in\n    C:\\Users\\sbiwk\\AppData\\Local\\Temp\\RtmpuEXbAO\\downloaded_packages\n\n\nThen you must always run the library() function to open that package:\n\nlibrary(\"maps\")\n\nWarning: package 'maps' was built under R version 4.5.1\n\n\nNow we can use the map() function (which comes from the “maps” package):\n\nmap(\"world\")\n\n\n\n\n\n\n\n\nNOTE: We will explore more data visualisations like this one in the next script.\n\n\nCiting R\nWhenever we use R in a report or assignment we should cite it.\nTo get the R citation we just run citation()\n\ncitation()\n\nIf we want to cite a specific package we can do it like this:\n\ncitation(\"maps\")\n\n\n\n\nTasks\nWrite your own code to complete the following 6 tasks. NOTE: You will not be assessed on these tasks. They are just designed to encourage you to practice.\nNOTE: You aren’t expected to remember how to do all of these yet!\nHINT: Look back at earlier sections of your script to find the bits of code that you need, and adapt them (that’s the best way to work in R)\n\n\n\n\n\n\nTask 1\n\n\n\n\n\nCreate an object called “seq1” which consists of a sequence of numbers from 5 to 100, in intervals of 1\n\n\n\n\n\n\n\n\n\nTask 2\n\n\n\n\n\nCalculate the middle value of seq1\n\n\n\n\n\n\n\n\n\nTask 3\n\n\n\n\n\nWhat is the total value of this sequence of numbers?\n\n\n\n\n\n\n\n\n\nTask 4\n\n\n\n\n\nInstall and load the “car” package\n\n\n\n\n\n\n\n\n\nTask 5\n\n\n\n\n\nCopy and paste here the citation for the “car” package:\n\n\n\n\n\n\n\n\n\nTask 6\n\n\n\n\n\nFinally, create a random set of ten-thousand numbers from a normal distribution with a mean of 5 and a standard deviation of 2"
  },
  {
    "objectID": "index.html#welcome-to-bi1001-biostatistics-practicals",
    "href": "index.html#welcome-to-bi1001-biostatistics-practicals",
    "title": "BI1001 Biostatistics Practicals",
    "section": "",
    "text": "This site contains all the practicals for the BI1001 Biostatistics module.\nClick on a practical below to get started:"
  },
  {
    "objectID": "Practical 1 - Exploring data and graphing.html",
    "href": "Practical 1 - Exploring data and graphing.html",
    "title": "Practical 1 - Exploring data and graphing",
    "section": "",
    "text": "Learning Outcomes (LOs)\nHere’s what you should know and be able to do after completing this practical:\n\nLO1: Create a basic plot using plot()\nLO2: Create a dataframe\nLO3: Explore a dataframe\nLO4: Create boxplots, q-q plots, histograms, and scatterplots\nLO5: Subset data using subset() and indexing []\nLO6: Calculate some basic descriptive statistics\nLO7: Import data into R\nLO8: Remove objects from the R Environment\n\n\n\nTutorial\n\nSimple plot of data\nR can be used to plot data\nLet’s create some objects and plot them against each other:\n\nX &lt;- seq(1, 100, 1)\nY &lt;- rnorm(100, 10, 5)\nplot(Y ~ X)\n\n\n\n\n\n\n\n\nNOTE: Here we use a new function; the plot() function\nWe have also used a new symbol ~\nThis symbol is called “tilde”\nWhenever you see it, think of the phrase “as a function of”\nHence here we are plotting Y as a function of X\n\n\nBasic data exploration\nNext, we are going to create some objects, and then combine them in a dataframe\nNOTE: In R, a dataset is called a “dataframe”\n\nID &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\")\nheight &lt;- rnorm(12, 160, 12)\nweight &lt;- rnorm(12, 70, 10)\ngender &lt;- rep(c(\"male\",\"female\",\"non-binary\"), each = 4)\n\nIf you don’t recognise any of the code or functions above, look back at the Practical 1 - Basics of R script.\nWe can now combine these objects into a dataframe, which we will call dframe1:\n\ndframe1 &lt;- data.frame(ID, height, weight, gender)\n\nThis dataset contains the heights and weights of 12 different people. These people are coded with anonymous identification letters. The heights and weights are randomly simulated.\nWe can now use some simple functions to explore the dataset:\n\nNames\nWe can use the names() function to see what the column names are:\n\nnames(dframe1)\n\n[1] \"ID\"     \"height\" \"weight\" \"gender\"\n\n\n\n\nHead\nUse head() to view the first few rows:\n\nhead(dframe1)\n\n  ID   height   weight gender\n1  A 176.7276 63.78922   male\n2  B 174.8045 80.06525   male\n3  C 164.5018 72.67232   male\n4  D 162.7823 71.45966   male\n5  E 150.2081 72.29918 female\n6  F 131.6022 70.96118 female\n\n\n\n\nTail\nUse tail() to view the last few rows:\n\ntail(dframe1)\n\n   ID   height   weight     gender\n7   G 161.3414 83.40135     female\n8   H 161.4050 74.24654     female\n9   I 160.8439 65.38419 non-binary\n10  J 150.2123 71.26006 non-binary\n11  K 166.9410 69.27487 non-binary\n12  L 179.0773 58.09131 non-binary\n\n\n\n\nView\nIf you want to look at the whole dataset, like you would see it in a spreadsheet, you can use View()\nNOTE: This will open in a new tab next to your script. You need to click on the “x” to close it.\n\nView(dframe1)\n\n\n\nStructure\nExamine the structure of the dataset using str(). Remember that we looked at this function in the previous script, as applied to a single variable. Here we are applying it to a dataset:\n\nstr(dframe1)\n\n'data.frame':   12 obs. of  4 variables:\n $ ID    : chr  \"A\" \"B\" \"C\" \"D\" ...\n $ height: num  177 175 165 163 150 ...\n $ weight: num  63.8 80.1 72.7 71.5 72.3 ...\n $ gender: chr  \"male\" \"male\" \"male\" \"male\" ...\n\n\nWe can see that these data contain two character variables, and two numeric variables. If we wanted to change a character variable to a factor, we could do it like this:\n\ndframe1$gender &lt;- as.factor(dframe1$gender)\n\nYou will have noticed that we used the dollar symbol $ to specifically choose the gender column from the dframe1 dataset.\n\n\nSummary\nThen we can use the summary() function, which shows us some basic descriptive statistics or other information from the variables in the dataset.\n\nsummary(dframe1)\n\n      ID                height          weight             gender \n Length:12          Min.   :131.6   Min.   :58.09   female    :4  \n Class :character   1st Qu.:158.2   1st Qu.:68.30   male      :4  \n Mode  :character   Median :162.1   Median :71.36   non-binary:4  \n                    Mean   :161.7   Mean   :71.08                 \n                    3rd Qu.:168.9   3rd Qu.:73.07                 \n                    Max.   :179.1   Max.   :83.40                 \n\n\n\n\n\nPlotting data\nLet’s now have a go at plotting some of the data from dframe1.\n\nPlot\nLet’s start by plotting the height using plot()\nNOTE: If we want to plot a single variable from the dataset, we use the dollar symbol $ to specify. plot() will just shows us the values of the variable on the y-axis, with the “index” (the observation number) on the x-axis:\n\nplot(dframe1$height)\n\n\n\n\n\n\n\n\n\n\nBoxplot\nWe can plot a boxplot() as follows:\n\nboxplot(dframe1$height)\n\n\n\n\n\n\n\n\nNote that there is some code you will see later which allows us to add y-axis and x-axis labels. Boxplots are good at looking at the distribution of data. It also shows us if there are any possible outliers.\n\n\nHistogram\nWe can use histograms with hist() to examine the distribution of the data:\n\nhist(dframe1$height)\n\n\n\n\n\n\n\n\n\n\nQ-Q plots (Quantile-Quantile plot)\nFinally, we can use a Q-Q plot. This will also inform us about the distribution of the data.\nNOTE: We plot a Q-Q plot using the qqnorm() function. However, we also need to use qqline() to plot a diagonal line on the plot:\n\nqqnorm(dframe1$height)\nqqline(dframe1$height)\n\n\n\n\n\n\n\n\nIf our data were normally distributed, we would expect our observations (the points) to sit on the diagonal line.\nNOTE: It’s sometimes easier to execute two functions on the same line of code.\nYou can do this by separating your functions by a semi-colon, like this:\n\nqqnorm(dframe1$height); qqline(dframe1$height)\n\n\n\n\n\n\n\n\nTo make sure you know what a Q-Q plot will look like for normally distributed data, let’s simulate a larger sample and plot that:\n\nsample &lt;- rnorm(1000, 10, 1) \nqqnorm(sample); qqline(sample)\n\n\n\n\n\n\n\n\nYou’ll see in the above that most of the observations sit on the diagonal line. There may be a small number of observations that don’t sit perfectly on the line, but that’s fine. What you don’t want to see are considerable or consistent deviations away from the diagonal.\n\n\n\nSubsetting a dataframe with indexing\nSometimes we may want to only look at some observations from a dataset. To do this we would need to perform “subsetting”. We can subset in a few ways.\nFirst, we’re going to look at “indexing”. We use square brackets [] for this.\nAll we do is we type the name of the dataframe object, and then put square brackets afterwards. Then, we put two numbers in those square brackets.\nThe first number represents the row number(s) and the second number represents the column number(s).\nFor example, look at the observations in the first row:\n\ndframe1[1,]\n\n  ID   height   weight gender\n1  A 176.7276 63.78922   male\n\n\nBecause we have not specified any columns, we get them all.\nNext, let’s look at all of the rows for the first column:\n\ndframe1[,1]\n\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\"\n\n\nIf we want to look at more than one column or row at a time, we can easily do that:\n\ndframe1[1:2,]\n\n  ID   height   weight gender\n1  A 176.7276 63.78922   male\n2  B 174.8045 80.06525   male\n\ndframe1[,1:2]\n\n   ID   height\n1   A 176.7276\n2   B 174.8045\n3   C 164.5018\n4   D 162.7823\n5   E 150.2081\n6   F 131.6022\n7   G 161.3414\n8   H 161.4050\n9   I 160.8439\n10  J 150.2123\n11  K 166.9410\n12  L 179.0773\n\n\nWe could also state directly the column names instead:\n\ndframe1[,c(\"ID\", \"height\")]\n\n   ID   height\n1   A 176.7276\n2   B 174.8045\n3   C 164.5018\n4   D 162.7823\n5   E 150.2081\n6   F 131.6022\n7   G 161.3414\n8   H 161.4050\n9   I 160.8439\n10  J 150.2123\n11  K 166.9410\n12  L 179.0773\n\n\nAnd here is an example of doing a combination of both. Specifically, let’s look at the height and weight column only for the first 3 individuals:\n\ndframe1[1:3, 2:3]\n\n    height   weight\n1 176.7276 63.78922\n2 174.8045 80.06525\n3 164.5018 72.67232\n\ndframe1[1:3, c(\"height\",\"weight\")]\n\n    height   weight\n1 176.7276 63.78922\n2 174.8045 80.06525\n3 164.5018 72.67232\n\n\nNOTE: If we wanted to, we could store this inside a new object. Here I name that object “sub” which is short for subset:\n\nsub &lt;- dframe1[1:3, c(\"height\",\"weight\")]\n\nWe can use subsetting to overwrite values in a dataset.\nFor example, imagine we found that the 3rd weight value in the data was erroneous.\nWe would in that case want to replace that value with NA (a missing observation).\nTo do that we could simply write:\n\ndframe1[3, \"weight\"] &lt;- NA\n\nNow if we look at the weight of the first few individuals, we can see that the third one has changed to NA:\n\ndframe1[1:5, \"weight\"]\n\n[1] 63.78922 80.06525       NA 71.45966 72.29918\n\n\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow you have a go at some indexing.\nCreate an object called “sub2” and store inside that object the weight and gender data for the first 5 individuals\n\n\n\n\n\nSelecting observations from a specific column:\nWe can also select specific observations from a single column using indexing.\nNOTE: When we do this, because a single variable doesn’t have both rows and columns, we don’t need two numbers inside the square brackets. Instead, we can use something called a logical statement.\nFor example, let’s look at the heights of individuals that only identify as male. To do this we take the height column from the dataset, and then index it specifically for when gender is equal to male:\n\ndframe1$height[dframe1$gender==\"male\"]\n\n[1] 176.7276 174.8045 164.5018 162.7823\n\n\nThe use of two equal symbols is important. You’ll notice if you try to run this same line of code with only 1 equal symbol, it gives you an error:\n\ndframe1$height[dframe1$gender=\"male\"]\n\nThis is because strictly speaking the two equals symbols is the comparison operator. It checks equality. Whereas the single equal symbol actually performs the same thing as the assignment operator &lt;-\nThe way I remember it is to think of the first equal sign as meaning “is” and the second equal sign as meaning “equal to”. Hence two equals signs means: “is equal to”.\nThus, this line of code is literally asking R to tell you the height data when gender “is equal to” male.\nIf we wanted to, we could calculate the mean height of the male individuals:\n\nmean(dframe1$height[dframe1$gender==\"male\"])\n\n[1] 169.704\n\n\nIf we wanted to now calculate the mean weight of the male individuals, we would in theory use the same code, but just change height to weight:\n\nmean(dframe1$weight[dframe1$gender==\"male\"])\n\n[1] NA\n\n\nHmm… That’s odd. Why is it showing us NA?\nThat’s because, as you’ll remember from the Basics of R script, when there are\nNAs in the data, R cannot calculate a mean unless you put na.rm = TRUE\nLet’s try it with that added in:\n\nmean(dframe1$weight[dframe1$gender==\"male\"], na.rm = TRUE)\n\n[1] 71.77137\n\n\nNow it works.\nHINT: A slightly adapted version of the line of code above might come in handy for the BI1004 SBA!\n\n\nSubsetting using the subset() functions\nWe can also perform subsetting using the subset() function.\nLet’s subset only the individuals with ID of “A”, “B”, and “C”:\n\nsubset(dframe1, ID %in% c(\"A\",\"B\",\"C\"))\n\n  ID   height   weight gender\n1  A 176.7276 63.78922   male\n2  B 174.8045 80.06525   male\n3  C 164.5018       NA   male\n\n\nAgain we could store this inside an object, if we wanted to:\n\nABC &lt;- subset(dframe1, ID %in% c(\"A\",\"B\",\"C\"))\nABC\n\n  ID   height   weight gender\n1  A 176.7276 63.78922   male\n2  B 174.8045 80.06525   male\n3  C 164.5018       NA   male\n\n\nWe can again perform logical statements in the subset function.\nFor example, subset individuals taller than 160cm:\n\nover160cm &lt;- subset(dframe1, height &gt; 160)\nover160cm\n\n   ID   height   weight     gender\n1   A 176.7276 63.78922       male\n2   B 174.8045 80.06525       male\n3   C 164.5018       NA       male\n4   D 162.7823 71.45966       male\n7   G 161.3414 83.40135     female\n8   H 161.4050 74.24654     female\n9   I 160.8439 65.38419 non-binary\n11  K 166.9410 69.27487 non-binary\n12  L 179.0773 58.09131 non-binary\n\n\nOr individuals who weigh less than 65 kg\n\nunder65kg &lt;- subset(dframe1, weight &lt; 65)\nunder65kg\n\n   ID   height   weight     gender\n1   A 176.7276 63.78922       male\n12  L 179.0773 58.09131 non-binary\n\n\n\n\n\n\n\n\nNoteHave a go\n\n\n\n\n\nNow you have a go.\nUse the subset function to create a subset for only the male and females\n\n\n\n\n\nRemoving objects from the “R Environment”\nIf we wanted to remove something that we have created in R, such as an object or dataframe, we can use the function rm()\nFor example, let’s remove the “over160cm” and “under65kg” objects:\n\nrm(over150cm)\n\nWarning in rm(over150cm): object 'over150cm' not found\n\nrm(over65kg)\n\nWarning in rm(over65kg): object 'over65kg' not found\n\n\nIn fact we could type more than one thing inside rm()\nLet’s remove both “ABC” and “sub”:\n\nrm(sub, ABC)\n\nIf you want to know what R has in it’s Environment at any time, you can simply run the ls() function:\n\nls()\n\n [1] \"dframe1\"   \"gender\"    \"height\"    \"ID\"        \"over160cm\" \"sample\"   \n [7] \"under65kg\" \"weight\"    \"X\"         \"Y\"        \n\n\nIn fact, we can use this to remove everything from R’s Environment.\nCAUTION: Be very careful using this code, because it will delete everything you had already created in R!\n\nrm(list=ls())\n\nIf you ran the code above, it will have cleared your Environment. See on the right-hand side, your “Environment” is now empty.\n\n\nImporting data\nLet’s start working with some real data\nWe are going to be looking at some physiological data collected on students\nSpecifically, we’re going to be looking at the “Respiratory Flow” dataset\nThese data are saved in a file called “RespiratoryFlow.csv”\nGo to Learning Central and download “RespiratoryFlow.csv”\nThis dataset measures respiratory flow in a sample of students.\nThe dataset also contains some other variables: height, weight, age and gender.\nOnce you have downloaded the data, you can then use the read.csv() function to import it.\nInside the read.csv() function, we include another function called file.choose()\nIMPORTANT: If you run this code, it will open a new window on your device. You will need to navigate to the dataset that you have downloaded (it will most likely be in your “Downloads” folder) and then select it and open it:\n\nflowData &lt;- read.csv(file.choose(), header = T, na.strings = \"\", stringsAsFactors = T)\n\nNOTE: There is a lot going on in the above line of code:\n\nheader = T: This tells R that the first row in the dataset consists of column headers\nna.strings = \"\": This tells R that any cells in the dataset which are blank need to be set to “NA”\nstringsAsFactors = T: This tells R that any words or letters (i.e. characters) in the dataset should be set as factors i.e. categorical groups.\n\n\n\nExplore the data\nYou should now have “flowData” in your Environment. You can now explore the data:\n\nnames(flowData)\n\n[1] \"student\" \"height\"  \"weight\"  \"age\"     \"gender\" \n\nhead(flowData)\n\n  student height weight age gender\n1       1    163   63.4  20      F\n2       2    173   66.9  18      F\n3       3    168   65.0  18      F\n4       4    169   82.0  18      F\n5       5    162   59.0  18      F\n6       6    172   68.0  19      F\n\ntail(flowData)\n\n    student height weight age gender\n206     206    174   64.2  18      M\n207     207    176   61.9  19   &lt;NA&gt;\n208     208    165     NA  NA   &lt;NA&gt;\n209     209    176   75.0  19   &lt;NA&gt;\n210     210    173   56.0  21   &lt;NA&gt;\n211     211    167   60.0  21   &lt;NA&gt;\n\nstr(flowData)\n\n'data.frame':   211 obs. of  5 variables:\n $ student: int  1 2 3 4 5 6 7 8 9 10 ...\n $ height : num  163 173 168 169 162 172 159 161 171 172 ...\n $ weight : num  63.4 66.9 65 82 59 68 52 51.6 64.8 68 ...\n $ age    : int  20 18 18 18 18 19 18 20 19 18 ...\n $ gender : Factor w/ 2 levels \"F\",\"M\": 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(flowData)\n\n    student          height          weight            age        gender   \n Min.   :  1.0   Min.   :147.0   Min.   : 37.20   Min.   :17.0   F   :126  \n 1st Qu.: 53.5   1st Qu.:167.0   1st Qu.: 58.92   1st Qu.:18.0   M   : 80  \n Median :106.0   Median :173.0   Median : 65.20   Median :18.0   NA's:  5  \n Mean   :106.0   Mean   :173.1   Mean   : 68.16   Mean   :18.8             \n 3rd Qu.:158.5   3rd Qu.:179.0   3rd Qu.: 75.00   3rd Qu.:19.0             \n Max.   :211.0   Max.   :210.0   Max.   :178.00   Max.   :28.0             \n                                 NA's   :1        NA's   :1                \n\n\n\n\nPlot some of the data\nLet’s start by plotting height against weight. We can include lots of arguments in the plot() function to tell R some specific details of what it should plot.\nFor example:\n\nUse xlab to change the x-axis label\nUse ylab to change the y-axis label\npch = plot character. Here we are using number 20 - see ?pch\ncol = \"red\" changes the colour of the points to red\nChanging the las changes the rotation of the axis labels. If you set las = 1, it makes the axis labels all horizontal\n\n\nplot(flowData$height ~ flowData$weight, \n     xlab = \"Height (cm)\",\n     ylab = \"Weight (kg)\",\n     pch = 20,\n     col = \"red\",\n     las = 1)\n\n\n\n\n\n\n\n\nNext, let’s look at a boxplot which shows us how height varies between genders:\n\nboxplot(flowData$height ~ flowData$gender, \n        ylab = \"Height (cm)\", \n        xlab = \"Gender\", \n        names = c(\"Female\", \"Male\"), \n        pch = 20, \n        las = 1)\n\n\n\n\n\n\n\n\nNow, these data don’t have any information about ethnicity, so let’s make some up!\nFirst, create an object called “ethnicities” which contains 4 different ethnicities:\n\nethnicities &lt;- as.factor(c(\"White\", \"Black\", \"Asian\", \"Other\"))\n\nThen, we can use the sample() function to randomly select an ethnicity for each observation in our flowData. We can store this inside a new column we create called ethnicity:\n\nflowData$ethnicity &lt;- sample(ethnicities, 211, replace = T)\n\nThe sample code is saying the following:\nRandomly sample from the ethnicities object. Specifically, randomly select 211 observations. The replace = T sets replacement to TRUE. This means once an ethnicity has been selected, it is then put back and so can by chance be selected again.\nNow that we have these data, we could produce a boxplot that shows data across two categorical groups (both gender and ethnicity):\n\nboxplot(flowData$height ~ flowData$gender * flowData$ethnicity, \n        ylab = \"Height (cm)\", \n        xlab = \"Gender\", \n        pch = 20, \n        las = 3)\n\n\n\n\n\n\n\n\nOh, there’s an issue with this figure.\nThe Gender x-axis label overlaps with the names of the groups.\nOne solution is to plot the figure, but do not display an x-axis just yet:\n\nboxplot(flowData$height ~ flowData$gender * flowData$ethnicity, \n        ylab = \"Height (cm)\", \n        xlab = \"\", \n        pch = 20, \n        las = 3)\n\n\n\n\n\n\n\n\nThen you could write in the figure legend that “F” and “M” represent Female and Male, respectively.\nAlternatively, we could use some code to change the way the figure is plotted so that there is more space to show the x-axis label. Here’s how we do this:\n\npar(mar = c(7, 4, 4, 2))\n\npar() is the function to change graphical parameters. The mar argument allows us to set the size of the margins (bottom, top, left, right).\nBy default the margins are c(5, 4, 4, 2) + 0.1.\nWe have set these to c(7, 4, 4, 2)\nNow we can re-plot the boxplot and you’ll see there’s more space at the bottom.\nAnd we can manually add an x-axis label using the mtext() function:\n\nboxplot(flowData$height ~ flowData$gender * flowData$ethnicity, \n        ylab = \"Height (cm)\", \n        xlab = \"\", \n        pch = 20, \n        las = 3)\nmtext(\"Gender.Ethnicity\", side = 1, line = 4.5)\n\n\n\n\n\n\n\n\n\nside = 1 tells R to plot the text on the bottom axis\nline = 4.5 tells R how far down the bottom axis to plot (higher number = further down)\n\n\n\nExamine the data distributions\nRemember from the lecture that the distribution of data is important to examine.\nWe can apply histograms and Q-Q plots to numeric data:\n\nhist(flowData$height)\n\n\n\n\n\n\n\nqqnorm(flowData$height);qqline((flowData$height))\n\n\n\n\n\n\n\n\nheight looks quite normal.\nWhat about weight?\n\nhist(flowData$weight)\n\n\n\n\n\n\n\nqqnorm(flowData$weight);qqline((flowData$weight))\n\n\n\n\n\n\n\n\nThis definitely looks odd - there is a clear curved pattern in the data.\nWe can also plot the distribution of categorical data. We can do this just using plot().\nWhen plot() is applied to a categorical variable, it will default to a barplot and show us how many observations of each category exists:\n\nplot(flowData$gender)\n\n\n\n\n\n\n\nplot(flowData$ethnicity)\n\n\n\n\n\n\n\n\nIn fact, we can see the same numbers by using the table() function:\n\ntable(flowData$gender)\n\n\n  F   M \n126  80 \n\ntable(flowData$ethnicity)\n\n\nAsian Black Other White \n   54    64    44    49 \n\n\nIf we wanted to plot a barplot specifically, we can’t just apply barplot to a categorical variable. The following will give you an error:\n\nbarplot(flowData$gender)\n\nThis is because barplot needs numbers to plot. These numbers would represent the heights of the bars. In fact, we can get this from the table() function, so we could use that:\n\nbarplot(table(flowData$gender))\n\n\n\n\n\n\n\n\n\n\nData transformations\nLet’s look again at the weight data:\n\nhist(flowData$weight)\n\n\n\n\n\n\n\n\nThis does not look normally distributed. Indeed, we saw that in the Q-Q plot:\n\nqqnorm(flowData$weight); qqline(flowData$weight)\n\n\n\n\n\n\n\n\nLet’s apply some mathematical transformations to the weight values to see if we can make them normally distributed.\nNOTE: You can nest a transformation function e.g. log() within a plotting function e.g., hist()\nLet’s try a natural logarithm transformation first:\n\nhist(log(flowData$weight))\n\n\n\n\n\n\n\nqqnorm(log(flowData$weight)); qqline(log(flowData$weight))\n\n\n\n\n\n\n\n\nlog looks better.\nWhat about a square root transformation?\n\nhist(sqrt(flowData$weight))\n\n\n\n\n\n\n\nqqnorm(sqrt(flowData$weight)); qqline(sqrt(flowData$weight))\n\n\n\n\n\n\n\n\nThis looks a bit worse.\nWhat about an exponential transformation?\n\nhist(exp(flowData$weight))\n\n\n\n\n\n\n\nqqnorm(exp(flowData$weight)); qqline(exp(flowData$weight))\n\n\n\n\n\n\n\n\nThis definitely hasn’t worked!\nThe best one was log() so let’s stick with that one.\nWe can store a transformed version of a variable inside the original dataset by creating a new column:\n\nflowData$logWeight &lt;- log(flowData$weight)\n\n\n\nAdding colour to a scatterplot\nSo far we have seen how to plot a scatter plot with two variables.\nThe following code shows you how to add a third variable to a plot using colour.\nStart by choosing the two colours you want to represent male and female, respectively:\n\ncolours &lt;- c(M = \"black\", \n             F = \"lightgrey\")\n\nThen, when you plot the data, you can use some clever indexing in the col argument.\nNOTE: You must make sure the variable is a “Character” for this to work.\n\nplot(height ~ weight, data = flowData, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = colours[as.character(flowData$gender)], \n     las = 1)\n\n\n\n\n\n\n\n\nRemember that plots like these should have a legend, otherwise it’s not obvious what the colours represent.\nLet’s plot it again but this time including a legend:\n\nplot(height ~ weight, data = flowData, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = colours[as.character(flowData$gender)], \n     las = 1)\nlegend(\"bottomright\", \n       legend = c(\"Male\", \"Female\"), \n       col = c(\"black\", \"lightgrey\"),\n       pch = 20, \n       title = \"Gender\") \n\n\n\n\n\n\n\n\n\nbottomright = Position of the legend\nlegend = c(\"Male\", \"Female\") = Labels in the legend\ncol = = Colours corresponding to the labels\npch = 20 = Symbol used in the legend\ntitle = = Title of the legend\n\nNote that you don’t have to change the colours, you could change the plot characters:\n\nchrs &lt;- c(M = 16, \n          F = 1)\nplot(height ~ weight, \n     data = flowData, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = chrs[as.character(flowData$gender)], \n     col = \"black\", \n     las = 1)\nlegend(\"bottomright\",\n       legend = c(\"Male\", \"Female\"),\n       col = \"black\",\n       pch = c(16, 1),\n       title = \"Gender\")\n\n\n\n\n\n\n\n\n\n\nPlotting data separately\nAlternatively you could plot males and females separately in two plots.\nStart by creating two subsets of the data:\n\nmale &lt;- subset(flowData, gender == \"M\") \nfemale &lt;- subset(flowData, gender == \"F\") \n\nNow use the droplevels() function to remove any categories that are no longer needed:\n\nmale &lt;- droplevels(male)\nfemale &lt;- droplevels(female)\n\nBefore we create the plots, we can change the way R displays subsequent figures.\nWe can do this again using par() but this time using the mfrow argument\nmfrow=c(1,2) means that the NEXT plots you produce will exist in a 1 row, 2 column array:\n\npar(mfrow=c(1,2))\nplot(height ~ weight, \n     data = female, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"black\", \n     las = 1)\nplot(height ~ weight, \n     data = male, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"red\", \n     las = 1)\n\n\n\n\n\n\n\n\nWe could make it so that they appear one above the other rather than side-by-side:\n\npar(mfrow=c(2,1))\nplot(height ~ weight, \n     data = female, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"black\", \n     las = 1)\nplot(height ~ weight, \n     data = male, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"red\", \n     las = 1)\n\n\n\n\n\n\n\n\nIf we are going to compare them like this then it makes more sense to put them all on the same axes.\nHence we can use xlim and ylim to adjust the axes ranges.\nWe can also use xaxp to adjust the positions of the x-axis tick marks to c(start, end, number of ticks).\n\npar(mfrow=c(2,1))\nplot(height ~ weight, \n     data = female, \n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"black\", \n     las = 1, \n     xlim = c(35, 185), \n     ylim = c(145, 215),\n     xaxp = c(30, 190, 16))\nplot(height ~ weight, \n     data = male,\n     xlab = \"Weight (kg)\", \n     ylab = \"Height (cm)\", \n     pch = 20, \n     col = \"red\",\n     las = 1, \n     xlim = c(35, 185), \n     ylim = c(145, 215),\n     xaxp = c(30, 190, 16))\n\n\n\n\n\n\n\n\nSo, hopefully you can see that there are lots of ways to explore data!\nWe can change the plot region back to normal with:\n\npar(mfrow=c(1,1))\n\n\n\n\nTasks\nWrite your own code to complete the following 6 tasks. NOTE: You will not be assessed on these tasks. They are just designed to encourage you to practice.\nNOTE: You aren’t expected to remember how to do all of these yet!\nHINT: Look back at earlier sections of your script to find the bits of code that you need, and adapt them (that’s the best way to work in R)\n\n\n\n\n\n\nNoteTask 1\n\n\n\n\n\nSubset the flowData so that you only have data from Asian individuals\n\n\n\n\n\n\n\n\n\nNoteTask 2\n\n\n\n\n\nNow plot the association between height and age of Asian individuals\n\n\n\n\n\n\n\n\n\nNoteTask 3\n\n\n\n\n\nCreate this plot again, but this time provide your own axes labels\n\n\n\n\n\n\n\n\n\nNoteTask 4\n\n\n\n\n\nAgain, create the plot, but this time ALSO change the type of plot symbol\n\n\n\n\n\n\n\n\n\nNoteTask 5\n\n\n\n\n\nNow go back to using the original flowData. Explore transformations of male weight - what looks to be the most “normal”?\n\n\n\n\n\n\n\n\n\nNoteTask 6\n\n\n\n\n\nUsing the original flowData, create a boxplot of weight as a function of gender - which gender looks heavier?\n\n\n\n\n\n\n\n\n\nNoteTask 7\n\n\n\n\n\nType ?boxplot and see if you can work out how to change the “notch” and “boxwex” for your boxplots. Set “notch” to TRUE and boxwex to 0.5"
  },
  {
    "objectID": "Practical 2 - Experimental design.html",
    "href": "Practical 2 - Experimental design.html",
    "title": "Practical 2 - Experimental design",
    "section": "",
    "text": "Learning Outcomes (LOs)\nHere’s what you should know and be able to do after completing this practical:\n\nLO1: Explain different sampling methods\nLO2: Write code to perform different sampling methods\nLO3: Simulate data, including from different distributions\nLO4: Run a basic loop\nLO5: Set a “seed” and explain what it does\nLO6: Explain how increased sample size affects estimates (of things like mean values)\nLO7: Subset data using subset() and indexing\nLO8: Explain the importance of replication\n\n\n\nTUTORIAL\n\nSimulating data and distributions\nIn this script will we be working with entirely simulated data. In other scripts, we will use more real data, but to exemplify experimental design concepts, it’s actually I think more helpful to work with simulated data.\nLet’s imagine a population that consists of 100,000 individuals.\nIn this first example, we are going to simulate the heights of 100,000 people.\nAcross the world, people differ in their heights considerably, but on average if you look across all adults, regardless of sex or gender, it’s reasonable to consider a typical mean height of 170 cm with a standard deviation of 10 cm. For examples, see: https://en.wikipedia.org/wiki/Average_human_height_by_country\nSo, let’s simulate a single variable, which is normally distributed and has a mean of 170 and a SD of 10.\nI’m calling this variable popHeights (population heights):\n\npopHeights &lt;- rnorm(100000, 170, 10)\n\nThis variable has been created using the rnorm() function, which generates random numbers from a normal distribution\nIf you want to see how the rnorm function works (or any function for that matter), type “?” followed by the function name:\n\n?rnorm\n\nWe saw rnorm() in the first script (Practical 1 - Basics of R) but as a reminder:\nThe rnorm() function has three arguments: n, mean, and sd\n\nn = the number of observations you want to simulate\nmean = this is the mean value of the normal distribution you want to simulate from\nsd = this is the sd of the distribution\n\nIf we wanted to, we could plot a quick histogram of the population heights, to take a look:\n\nhist(popHeights)\n\n\n\n\n\n\n\n\nRemember that in most scientific experiments, we wouldn’t collect data from the entire population.\nWe would instead collect a sample. Let’s look at how to do this:\nSuppose we want to measure the heights of a sample of 50 people from our population.\nWe can use the sample() function. We’ll store the sample of heights in a new object called sHeights:\n\nsHeights &lt;- sample(popHeights, 50, replace = FALSE)\n\nImportantly, in the above function I set replace = FALSE. This is to tell R that once an individual has been selected, they cannot be selected again. This is known as sampling without replacement and is typical for real world surveys, because you may not want to sample the same person’s height twice.\nIf I were to set replace = TRUE, this would simulate sampling with replacement: after selecting an individual, that person is returned to the population and could be chosen again.\nScientists sometimes do this in simulations to see how results might vary if we repeated an experiment.\nYou don’t need to worry about this for now — just know that it exists.\nLets look at our sample distribution:\n\nhist(sHeights)\n\n\n\n\n\n\n\n\nWe could, if we wanted to, calculate the mean of our sample:\n\nmean(sHeights)\n\n[1] 169.4768\n\n\nWe will explore sample distributions in more detail later. For now, let’s simulate a slightly more realistic scenario - one where we don’t just collect data on 1 variable, but on a few different variables.\nLet’s imagine a population of 100,000 humans who all have different heights, weights, ages, etc.:\n\npopulation &lt;- data.frame(\n  height = rnorm(100000, 170, 10),\n  weight = rnorm(100000, 65, 10),\n  age = rnorm(100000, 40, 15),\n  systolic_bp = rnorm(100000, 120, 15), \n  diastolic_bp = rnorm(100000, 80, 10), \n  cholesterol = rnorm(100000, 5, 1), \n  gender = sample(c(\"Male\", \"Female\", \"Other\"), 100000, replace = TRUE, prob = c(0.49, 0.49, 0.02)),\n  ethnicity = sample(c(\"White\", \"Black\", \"Asian\", \"Other\"), 100000, replace = TRUE, prob = c(0.3, 0.3, 0.3, 0.1)), \n  university = sample(LETTERS[1:10], 100000, replace = TRUE, prob = rep(0.1, 10))\n)\n\nThis simulation should take less than 1 second. R can handle very large datasets very quickly!\nLet’s make sure we tell R that the gender, ethnicity, and university variables are all categorical (factors):\n\npopulation$gender &lt;- as.factor(population$gender)\n\npopulation$ethnicity &lt;- as.factor(population$ethnicity)\n\npopulation$university &lt;- as.factor(population$university)\n\nFor gender, we’ve simulated a population where 49% of people are male, 49% are female, and 2% identify as another gender (e.g., non-binary, transgender, etc.).\nFor ethnicity, we’ve simulated a scenario where 30% of people are White, 30% are Black, 30% are Asian, and 10% belong to other ethnic groups.\nNOTE: These gender and ethnicity proportions are entirely hypothetical and are not intended to reflect real-world population data.\nWe’ve also simulated these people all attending one of 10 different universities.\nLet’s take a look at the first few rows of the dataset we just created:\n\nhead(population)\n\n    height   weight      age systolic_bp diastolic_bp cholesterol gender\n1 163.7340 60.38524 32.40891   116.95096     72.58885    5.986062 Female\n2 175.1240 62.63739 56.02810   122.23090     78.58567    5.318701 Female\n3 167.2548 61.60109 59.00962    93.00822     81.41694    6.402015 Female\n4 165.9889 56.46010 44.89440   138.65373     66.93459    5.680093 Female\n5 167.8507 58.96460 64.29158    94.55799     81.78346    5.243990 Female\n6 149.7072 43.88418 23.29390   133.20928     81.69787    5.394728 Female\n  ethnicity university\n1     Other          A\n2     Black          H\n3     White          F\n4     Black          B\n5     White          G\n6     Black          I\n\n\nNow we can start looking at some of the possible sampling strategies we might use to sample from this population.\n\n\nRandom sampling\nPick 30 individuals at random from the entire population.\nFirst we create an object called rowNums. In this we store 30 random numbers from 1:100000:\n\nrowNums &lt;- sample(1:100000, 30, replace = F)\n\nThen, we use that to select which rows to choose when performing indexing on our population:\n\nrandom_sample &lt;- population[rowNums, ]\n\nLet’s look at the first few of these randomly sampled individuals:\n\nhead(random_sample)\n\n        height   weight       age systolic_bp diastolic_bp cholesterol gender\n71997 173.4167 66.72732 65.828786   150.35917     84.51113    4.557183   Male\n29188 151.0610 76.92404 40.103356   132.28019     86.64372    3.970550   Male\n38235 162.3554 58.28435 40.561383   118.58302     88.43364    3.436988  Other\n45258 179.4690 58.86526  8.827247   121.09954     68.00353    3.775287 Female\n12428 179.4262 65.69037 27.543349    98.20427     66.77622    5.569272   Male\n85161 163.2085 69.28597 35.991957   101.72397     89.20401    4.265424 Female\n      ethnicity university\n71997     White          F\n29188     Black          E\n38235     White          C\n45258     Black          F\n12428     Black          I\n85161     White          D\n\n\nNote that the first column that you see represents the original row numbers within the population\n\n\nSystematic sampling\nLet’s now choose every 100th individual within the population. Let’s start by creating a sequence which takes every 100th individual starting from individual number 1:\n\nseq1 &lt;- seq(1, 100000, 100)\n\nThen, we use this seq1 in our indexing:\n\nsystematic_sample &lt;- population[seq1, ]\n\nLet’s look at the first few rows of these:\n\nhead(systematic_sample)\n\n      height   weight      age systolic_bp diastolic_bp cholesterol gender\n1   163.7340 60.38524 32.40891    116.9510     72.58885    5.986062 Female\n101 173.2800 67.89744 58.32461    112.0133     69.92040    6.027428 Female\n201 178.3876 66.78307 40.64089    108.0845     91.03511    5.599636   Male\n301 160.3027 62.14578 43.69996    130.8455     87.09648    5.002352 Female\n401 171.4518 56.20894 38.60510    140.2771     62.55093    4.359644   Male\n501 164.1242 55.16017 58.18916    111.8225     95.20551    4.201749 Female\n    ethnicity university\n1       Other          A\n101     White          G\n201     Black          I\n301     Black          G\n401     Asian          B\n501     Black          J\n\n\n\n\nStratified random sampling\nIn stratified random sampling we want to take a sample that proportionally represents the population.\nLet’s look at taking a stratified random sample according to gender.\nBefore we take a sample, we need to work out how many individuals we have of each gender. The table() function is good for this:\n\ntable(population$gender)\n\n\nFemale   Male  Other \n 49209  48823   1968 \n\n\nSo this is how many individuals we have of each gender. But what about as a proportion?\nFor this we can apply the prop.table() function to this table:\n\nprop.table(table(population$gender))\n\n\n Female    Male   Other \n0.49209 0.48823 0.01968 \n\n\nSo we have 48.634% female, 49.306% male, and 2.06% other.\nTo keep things simple, let’s round these numbers to whole percentages: 49%, 49% and 2%.\nWe can now use those values to perform our stratified random sampling.\nImagine we wanted a sample of 100 individuals in total. To keep our sample proportionally representative of the population, that would mean we have 49 male, 49 female, and 2 other.\nHere’s one way to do this. First, create some subsets:\n\nmale &lt;- subset(population, gender == \"Male\")\n\nfemale &lt;- subset(population, gender == \"Female\")\n\nother &lt;- subset(population, gender == \"Other\")\n\nNow, we can randomly sample 49, 49, and 2 individual from these respectively:\n\nsMale &lt;- male[sample(1:nrow(male), 49, replace = FALSE), ]\n\nsFemale &lt;- female[sample(1:nrow(female), 49, replace = FALSE), ]\n\nsOther &lt;- other[sample(1:nrow(other), 2, replace = FALSE), ]\n\nExplanation of the above:\n\nFor each gender, we first create a subset of the population.\nThen we use sample() to randomly select the desired number of rows.\nThe 1:nrow(data) part creates a sequence of row numbers that is specific to each dataset so that the sample() function knows which rows to pick from.\n\nWe now have our three subsets. We can combine them using rbind(), which stands for “row bind”.\nrbind() stacks the datasets on top of each other (adds rows), so all the selected individuals are together in one dataset. This works because all three subsets have the same columns and structure.\n\nstratified_sample &lt;- rbind(sMale, sFemale, sOther)\n\nLet’s have a look at this sample either using head() or View():\n\nhead(stratified_sample)\n\n        height   weight      age systolic_bp diastolic_bp cholesterol gender\n87297 159.1698 53.98689 81.21447   116.99043     92.60773    4.536632   Male\n44917 185.8663 60.39321 68.18638    93.23374     70.79063    4.265531   Male\n31033 168.4680 69.86534 47.80692   125.55947     62.66596    4.181329   Male\n99511 175.7290 47.28048 54.68130   133.67063     72.08258    4.843348   Male\n26496 170.0479 60.78241 34.61240   127.53828     89.32381    3.748579   Male\n20939 180.7642 51.42279 19.79746   119.21510     86.52422    6.298333   Male\n      ethnicity university\n87297     Black          H\n44917     Black          C\n31033     Asian          G\n99511     White          A\n26496     White          B\n20939     Asian          A\n\n\n\nView(stratified_sample)\n\n\n\nQuota sampling:\nWe can use a very similar approach to perform quota sampling.\nLet’s assume we want data on 5 individuals from each ethnicity.\nFirst, create ethnicity subsets:\n\nAsian &lt;- subset(population, ethnicity == \"Asian\") \nBlack &lt;- subset(population, ethnicity == \"Black\") \nWhite &lt;- subset(population, ethnicity == \"White\") \nOther &lt;- subset(population, ethnicity == \"Other\")\n\nNow select 5 individuals from each subset:\n\nsAsian &lt;- Asian[sample(1:nrow(Asian), 5, replace = FALSE), ] \nsBlack &lt;- Black[sample(1:nrow(Black), 5, replace = FALSE), ] \nsWhite &lt;- White[sample(1:nrow(White), 5, replace = FALSE), ] \nsOther &lt;- Other[sample(1:nrow(Other), 5, replace = FALSE), ]\n\nAnd again rbind() them:\n\nquota_sample &lt;- rbind(sAsian, sBlack, sWhite, sOther)\n\nHave a look, this time just print the entire dataset as it’s only small (20 individuals):\n\nquota_sample\n\n        height   weight      age systolic_bp diastolic_bp cholesterol gender\n723   172.3542 92.43438 53.92219    119.5229     81.32790    5.788778   Male\n81994 182.7927 74.73159 38.09562    124.8377     91.84278    5.818834 Female\n10115 169.0691 61.63868 49.54352    104.7324     95.33191    4.757712   Male\n93797 167.8878 70.97036 28.65571    104.6996     82.44269    4.407636  Other\n42805 173.2833 76.06125 51.48728    100.6446     69.76565    5.240613 Female\n20427 170.9550 69.41297 29.77902    104.8732     82.43871    6.166039   Male\n32236 157.3147 63.24448 27.77483    127.2926     91.69434    5.756530 Female\n4428  170.9878 79.96075 10.79650    145.9234     98.82285    4.958154   Male\n73445 164.5989 68.48101 19.53612    119.7823     69.45694    4.466238 Female\n58807 169.5485 73.77467 15.40029    140.2353     78.46538    6.190721 Female\n72595 168.1244 74.49595 30.19815    112.1273     72.68001    5.563528 Female\n19562 159.8313 64.39903 58.26997    114.6231     74.88763    4.839370 Female\n65704 144.7130 76.55472 32.22985    123.7118     86.43722    4.023154   Male\n75114 159.0263 75.63916 60.22882    146.0319     91.65359    4.728108 Female\n2398  168.1453 44.83831 21.68359    150.4932     83.09705    4.416930   Male\n67680 169.7186 72.43333 17.69338    124.8216     89.84654    5.562378 Female\n87899 173.4833 60.88831 48.92417    137.6457     81.55267    5.701701  Other\n30915 176.9280 72.94600 51.10427    121.5295     68.26622    5.964407 Female\n41744 168.4455 62.09899 64.52134    119.9390     82.81290    4.151993 Female\n26966 190.1175 65.33494 40.41858    131.3522     91.62385    4.493673   Male\n      ethnicity university\n723       Asian          J\n81994     Asian          I\n10115     Asian          H\n93797     Asian          H\n42805     Asian          H\n20427     Black          I\n32236     Black          C\n4428      Black          I\n73445     Black          I\n58807     Black          B\n72595     White          B\n19562     White          I\n65704     White          D\n75114     White          H\n2398      White          I\n67680     Other          A\n87899     Other          H\n30915     Other          I\n41744     Other          B\n26966     Other          J\n\n\n\n\nCluster sampling:\nFinally, let’s take a look at cluster sampling.\nThis is where we might select only a few specific clusters (characteristics), but include all individuals who have those characteristics. For example, let’s imagine we only wanted to look at people who went to three different universities (university A, B, and C):\n\nA &lt;- subset(population, university == \"A\") \nB &lt;- subset(population, university == \"B\") \nC &lt;- subset(population, university == \"C\")\n\nIn cluster sampling, we collect data on all individuals from those clusters. So we don’t need to perform any further sampling, we just rbind() the entire three clusters together:\n\nABC &lt;- rbind(A, B, C)\n\nNow we can have a look at it:\n\nhead(ABC)\n\n     height   weight      age systolic_bp diastolic_bp cholesterol gender\n1  163.7340 60.38524 32.40891   116.95096     72.58885    5.986062 Female\n12 156.3329 49.36824 26.90845    97.67188     82.46187    5.301338 Female\n15 174.7707 67.40698 34.13064   117.39393     87.47603    5.191696   Male\n18 167.3477 78.67354 22.52169   121.73052     80.54769    5.138100 Female\n21 162.6626 67.73389 32.56636   111.30826     70.93925    6.112494   Male\n25 162.9550 81.50480 50.31263   113.27377     75.60526    4.818764 Female\n   ethnicity university\n1      Other          A\n12     White          A\n15     Black          A\n18     Asian          A\n21     Asian          A\n25     White          A\n\ntail(ABC)\n\n        height   weight      age systolic_bp diastolic_bp cholesterol gender\n99976 169.0478 55.31067 48.51160    91.86275     80.88376    4.471764   Male\n99982 173.7271 69.85640 53.68481   123.58959     80.24406    4.371502   Male\n99988 161.1028 61.34225 55.27156   102.06583     79.64839    4.899352  Other\n99991 177.0440 66.93237 53.31681   132.25141     54.66097    4.283604  Other\n99994 178.9351 60.74264 50.01368   113.60997     87.62724    4.180310   Male\n99995 180.9390 83.07071 40.97223   116.78755     72.51579    5.163567 Female\n      ethnicity university\n99976     White          C\n99982     Black          C\n99988     White          C\n99991     Asian          C\n99994     White          C\n99995     Asian          C\n\ntable(ABC$university)\n\n\n    A     B     C     D     E     F     G     H     I     J \n10033 10001 10015     0     0     0     0     0     0     0 \n\n\nNotice how even though there are no longer any observations in the D-J universities, those categories still exist?\nWe can remove empty categories by using the droplevels() function:\n\nABC &lt;- droplevels(ABC)\n\nNow look again:\n\ntable(ABC$university)\n\n\n    A     B     C \n10033 10001 10015 \n\n\n\n\nSimulating data from different distributions\nSo far, whenever we have simulated numerical data, we have used the rnorm() function\nThis will specifically simulate data from a normal distribution.\nLet’s have another quick look at this: let’s simulate 100 normally distributed height observations\n\nheights &lt;- rnorm(n = 100, mean = 170, sd = 10)\n\nWe can look at this distribution using hist()\n\nhist(heights)\n\n\n\n\n\n\n\n\nR can simulate data from many different distributions. Let’s look at a few examples.\n\nPoisson Distribution\nThe Poisson distribution models count data (whole numbers like 0, 1, 2 etc.).\nIt has a single parameter, lambda, which determines both the mean and the variance.\nAn obvious biological example of count data are the number of eggs a bird lays.\nHere we simulate 100 random numbers from a Poisson distribution with lambda = 2:\n\npois &lt;- rpois(n = 100, lambda = 2)\n\nAgain, we can visualise the simulated data with a histogram:\n\nhist(pois, main = \"\", xlab = \"Number of eggs laid\", las = 1)\n\n\n\n\n\n\n\n\n\n\nBinomial Distribution\nThe binomial distribution models data that exists in one of two categories, e.g., success/failure.\nBiological example: We have 100 people suffering from pain and we want to test if a drug can reduce it.\nrbinom() parameters:\n\nn = number of individuals we are simulating (100 here)\nsize = number of “trials” per individual (1 if they get the drug once)\nprob = probability of success on each trial (probability the drug works)\n\n\nExample 1: Drug has 50% chance to reduce pain\n\nbinom &lt;- rbinom(n = 100, size = 1, prob = 0.5)\n\nhist(binom, main = \"\", xlab = \"0 = Same pain, 1 = Reduced pain\", las = 1)\n\n\n\n\n\n\n\n\n\n\nExample 2: Drug has 75% chance to reduce pain\n\nbinom2 &lt;- rbinom(n = 100, size = 1, prob = 0.75)\n\nhist(binom2, main = \"\", xlab = \"0 = Same pain, 1 = Reduced pain\", las = 1)\n\n\n\n\n\n\n\n\n\n\nExample 3: Each person gets 2 doses of the drug (size = 2)\nThe number now represents how many times the drug successfully reduced pain out of two attempts.\nAssuming that on both attempts the chance of reducing pain was 75%:\n\nbinom3 &lt;- rbinom(n = 100, size = 2, prob = 0.75)\n\nhist(binom3, main = \"\", xlab = \"Number of times pain was reduced (0, 1, 2)\", las = 1)\n\n\n\n\n\n\n\n\n\n\n\nBimodal distribution\nYou may remember from the exploring data and graphing lecture, I mentioned that spiders are often sexually dimorphic - females are typically larger than males.\nFor this you will need to install another package (if that doesn’t work, just skip over this bit):\n\ninstall.packages(\"FamilyRank\")\n\nlibrary(FamilyRank)\n\nThis distribution needs a total sample size, a mean and SD for each of the two peaks (modes) in the distribution, and a probability value which dictates the probability of being in mode 1.\n\nbinorm &lt;- rbinorm(n = 200,   # 200 spiders in total \n                  mean1 = 2, # mean for mode 1 (think of male spider diameter in cm) \n                  mean2 = 4, # mean for mode 2 (think of female spider diameter in cm) \n                  sd1 = 0.3, # SD for male spider diameter \n                  sd2 = 0.5, # SD for female spider diameter \n                  p1 = 0.5)  # Probability of being a male spider (50%)\n\nhist(binorm, main = \"\", las = 1, xlab = \"Spider diameter (cm)\")\n\nThere are many more possible distributions that data can follow, but we will stop here for now!\nJust remember (i) that data can follow different distributions - it won’t always be “normal” and (ii) that for many “Parametric” statistical tests, the tests assume your data are normal - so you must check! We will cover this in detail in the next script.\n\n\n\nExamining distributions\nLet’s have a look at some averages, and variation, of the distributions created above:\n\nNormal\n\nhist(heights) \nabline(v = mean(heights), col = \"blue\", lwd = 2) \nabline(v = median(heights), col = \"red\", lwd = 2) \n\n\n\n\n\n\n\nmean(heights) \n\n[1] 169.6709\n\nmedian(heights) \n\n[1] 170.2199\n\nsd(heights)\n\n[1] 11.10424\n\n\n\n\nPoisson\n\nhist(pois) \nabline(v = mean(pois), col = \"blue\", lwd = 2) \nabline(v = median(pois), col = \"red\", lwd = 2) \n\n\n\n\n\n\n\nmean(pois) # This should be close to 2 \n\n[1] 2\n\nvar(pois)  # This should be close to 2\n\n[1] 1.737374\n\n\n\n\nBinom\n\nhist(binom) \nabline(v = mean(binom), col = \"blue\", lwd = 2) \nabline(v = median(binom), col = \"red\", lwd = 2) \n\n\n\n\n\n\n\nmean(binom)  # This should be close to 50 % \n\n[1] 0.48\n\ntable(binom) # This should be close to a 50/50 split!\n\nbinom\n 0  1 \n52 48 \n\n\n\n\nBinorm\n\nhist(binorm) \nabline(v = mean(binorm), col = \"blue\", lwd = 2) \nabline(v = median(binorm), col = \"red\", lwd = 2) \nmean(binorm) # The mean of a bimodal distribution is not representative of a \"typical\" or \"average\" spider! \nsd(binorm)\n\nHopefully this exemplifies that best representation of the “average” value in a distribution isn’t always the mean!\n\n\n\nThe importance of sample size\nLook at what happens when we create a normal distribution with 10, 100, or 1000 observations:\n\nhist(rnorm(10,5,1)) \n\n\n\n\n\n\n\nhist(rnorm(100,5,1)) \n\n\n\n\n\n\n\nhist(rnorm(1000,5,1))\n\n\n\n\n\n\n\n\nWith increasing sample size, the distribution starts to look more normal\nWe know that in these simulated distributions the mean = 5 and sd = 1.\nIn theory, with increasing sample size, the estimated mean and SD should get more accurate.\nThis is because with more data (a larger sample size) we can estimate things more accurately.\n\nmean(rnorm(10,5,1)) \n\n[1] 4.888039\n\nmean(rnorm(100,5,1)) \n\n[1] 4.992794\n\nmean(rnorm(1000,5,1))\n\n[1] 4.993325\n\nsd(rnorm(10,5,1)) \n\n[1] 1.173447\n\nsd(rnorm(100,5,1)) \n\n[1] 1.084618\n\nsd(rnorm(1000,5,1))\n\n[1] 1.009126\n\n\nLet’s do something a little more complex…\nWe are going to use a “loop” - this is a way of performing repeated instructions over a series of iterations (i).\nBefore we do this, let’s set up our plotting window so that we have a 2 x 2 array of plots.\nWe must do this first (before plotting):\n\npar(mfrow=c(2,2)) # This tells R to plot all subsequent plots in a 2 x 2 array\n\nNow, let’s run a “for loop” to plot 4 histograms, each time with a different sample:\nWe can interpret this code as follows: For every iteration (i) in iterations 1 to 4, create a histogram of 10 observations drawn from a random normal distribution with a mean = 5 and sd = 1\nNOTE: You can run this over and over again, each time it will produce 4 different graphs:\n\nfor(i in 1:4) { \n  hist(rnorm(10, 5, 1)) \n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy does this matter?\nThis demonstrates the impact of replication. Imagine we were to take only a sample of data that consisted of 10 observations. Depending on which 10 observations we happen to select, our sample could look very different!\nOften we only perform an experiment once i.e., we only collect the first sample of 10 observations\nIn fact, we may want to repeat entire experiments multiple times (known as replication) in order to ensure that our results are robust.\nHere’s another example of this:\nSuppose we were measuring the height of young trees i.e., saplings (cm)\nWe won’t know in a real experiment what the true population looks like, but usefully in R we can simulate this.\nLet’s assume that the population consists of 1000 saplings, and on average they are 50 cm tall, with SD of 5 cm:\n\nsaplings &lt;- rnorm(1000, mean = 50, sd = 5)\n\nLet’s imagine now I do an experiment - I sample the heights of just 5 saplings:\n\nsaplings1 &lt;- sample(saplings, 5, replace = F)\n\nIf I now estimate the mean of that sample, what is it?\n\nmean(saplings1)\n\n[1] 44.40706\n\n\nNow let’s imagine I repeat that experiment. I go back into the field on a different day and measure 5 saplings again:\n\nsaplings2 &lt;- sample(saplings, 5, replace = F)\n\nIf I now estimate the mean of that second sample, what is it?\n\nmean(saplings2)\n\n[1] 50.97199\n\n\nThe chances are the means of saplings1 and saplings2 could be quite different to each other and also quite different to the true (simulated) mean of the population\nLet’s see what these samples both look like:\nPlot to visualize:\n\npar(mfrow=c(1,2))\n\nhist(saplings1, main=\"Sample 1 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightblue\", las = 1)\n\nhist(saplings2, main=\"Sample 2 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightgreen\", las = 1)\n\n\n\n\n\n\n\n\nDepending on what you happened to randomly sample on each occasion, these could look quite different!\nIn other words, when you repeat exactly the same experiment, you might end up with quite different results.\nIf you were to repeat this experiment many times, then you could calculate an average sapling height across ALL of your experiments. This would be a much more reliable/robust average than if you’d only done the experiment once.\nNow let’s have a look at if I were to do the experiment only twice, but this time collect a much larger sample of data on both occasions:\n\nsaplings1b &lt;- sample(saplings, 100, replace = F)\n\nsaplings2b &lt;- sample(saplings, 100, replace = F)\n\nIf we plot them again, we should see that these two distributions now look much more similar:\n\npar(mfrow=c(1,2))\n\nhist(saplings1b, main=\"Sample 1 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightblue\", las = 1)\n\nhist(saplings2b, main=\"Sample 2 (5 saplings)\", xlab=\"Height (cm)\", col=\"lightgreen\", las = 1)\n\n\n\n\n\n\n\n\nAnd if we were to calculate their means, not only should these both be more similar to each other, they should also both be more similar to what we know to be the true (simulated) mean in the population:\n\nmean(saplings1b)\n\n[1] 50.23517\n\nmean(saplings2b)\n\n[1] 50.16542\n\n\n\n\nSetting a seed\nThis may seem like an odd concept, but sometimes we want to generate a random set of numbers that is always the same set of random numbers!\nTo do this, we set a “seed”. Think of a seed as a specific instance of R.\nThe seed can be any number and must be set prior to running a random number generator:\n\nset.seed(1); rnorm(5, 5, 1)\n\n[1] 4.373546 5.183643 4.164371 6.595281 5.329508\n\n\nNotice what I have done on the above line is use the semi-colon “;” - This allows me to run two functions on the same line of code, one after the other.\nIf you run that line of code above again, you will always get the same 5 random numbers!\nCompare that to running the below line of code a few times, without setting a seed. You should get a random set of numbers every time:\n\nrnorm(5, 5, 1)\n\n[1] 4.179532 5.487429 5.738325 5.575781 4.694612\n\n\nWhy is setting a seed useful?\nSetting a seed is important for playing with simulations because it ensures results are reproducible every single time. This goes not just for you, but for anyone else running the code.\nSo, in theory, every single person running the following line of code should get the same set of 5 “random” numbers:\n\nset.seed(1); rnorm(5, 5, 1)\n\n[1] 4.373546 5.183643 4.164371 6.595281 5.329508\n\n\n\n\nSubsetting data\nWe have already seen some examples of subsetting data from a previous script, but it’s so useful it’s worth seeing a few more examples:\nLet’s create a new, simulated dataset.\nThis time we’re going to create data on Alzheimer’s patients\nWe are going to do this using a seed so that everyone sees exactly the same simulated data:\n\nset.seed(1); Alzheimers &lt;- data.frame(neurons = c(rnorm(100, 20, 5), rnorm(100, 20, 5)), \n                                      group = rep(c(\"Asymptomatic\",\"Symptomatic\"), each = 100), \n                                      sex = c(rep(\"M\", 50), rep(\"M\", 50), rep(\"F\", 50), rep(\"F\", 50)),\n                                      age = round(rnorm(200, 70, 5), 0))\n\nNote that the “neurons” variable represents the neuron cell density in patients\nHave a quick look:\n\nhead(Alzheimers)\n\n   neurons        group sex age\n1 16.86773 Asymptomatic   M  72\n2 20.91822 Asymptomatic   M  78\n3 15.82186 Asymptomatic   M  78\n4 27.97640 Asymptomatic   M  68\n5 21.64754 Asymptomatic   M  59\n6 15.89766 Asymptomatic   M  82\n\n\nThere are many different ways to subset data:\nSelecting for a particular group e.g. Males (all these 4 lines of code achieve the same thing!):\n\nmales &lt;- subset(Alzheimers, sex == \"M\")\n\nmales &lt;- subset(Alzheimers, sex %in% \"M\")\n\nmales &lt;- Alzheimers[Alzheimers$sex == \"M\", ]\n\nmales &lt;- Alzheimers[Alzheimers$sex %in% \"M\", ]\n\nSelecting against a particular group:\n\nAsymptomatic &lt;- subset(Alzheimers, group != \"Symptomatic\")\n\nSelecting individuals over or under a certain age:\n\nover70 &lt;- subset(Alzheimers, age &gt; 70)\n\nunder70 &lt;- subset(Alzheimers, age &lt; 70)\n\nSelecting individuals “greater than or equal to” a certain age:\n\natLeast60 &lt;- subset(Alzheimers, age &gt;= 60)\n\nSelecting individuals “less than or equal to” a certain age:\n\nage58orLess &lt;- subset(Alzheimers, age &lt;= 58)\n\nSelecting specific rows from a dataset:\n\nfirst10 &lt;- Alzheimers[1:10,]\n\nlast20 &lt;- Alzheimers[181:200,]\n\nSelecting specific rows AND columns:\n\nsubset &lt;- Alzheimers[50:100, 1:2] # Select rows 50 to 100, but only data from the first 2 columns\n\n\n\n\nTASKS\nWrite your own code to complete the following 6 tasks. NOTE: You will not be assessed on these tasks. They are just designed to encourage you to practice.\nNOTE: You aren’t expected to remember how to do all of these yet!\nHINT: Look back at earlier sections of your script to find the bits of code that you need, and adapt them (that’s the best way to work in R)\n\n\n\n\n\n\nNoteTask 1\n\n\n\n\n\nWrite the code to create a randomly generated dataset consisting of observations that follow a Poisson distribution with a mean value of 10. And write the code to plot this distribution.\n\n\n\n\n\n\n\n\n\nNoteTask 2\n\n\n\n\n\nWrite the code to execute a loop that plots 4 random poisson distributions where n = 10 and lambda = 2\n\n\n\n\n\n\n\n\n\nNoteTask 3\n\n\n\n\n\nWrite the code to subset the Alzheimers data so that you have a sample of 50 random individuals\n\n\n\n\n\n\n\n\n\nNoteTask 4\n\n\n\n\n\nWrite the code to plot a histogram of neuron cell density for only Symptomatic Alzheimer’s patients"
  }
]